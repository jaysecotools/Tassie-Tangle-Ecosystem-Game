<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tassie Tangle Game - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        
        :root {
            --primary: #2d5a3d;
            --secondary: #1a3c27;
            --accent: #4caf50;
            --danger: #d32f2f;
            --warning: #ff9800;
            --highlight: #ffeb3b;
            --text-light: #e8f5e9;
            --text-dark: #1a3c27;
        }
        
        body {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--primary) 100%);
            color: var(--text-light);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 25px;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr) !important;
            }
        }
        
        .game-header {
            grid-column: 1 / -1;
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            border: 2px solid var(--accent);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .game-title {
            font-size: clamp(1.8em, 4vw, 2.8em);
            background: linear-gradient(45deg, #81c784, #a5d6a7);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            font-weight: 800;
            letter-spacing: 0.5px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            text-align: center;
        }
        
        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(76, 175, 80, 0.3);
            transition: transform 0.3s, box-shadow 0.3s;
            min-width: 120px;
        }
        
        .stat-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.2);
        }
        
        .stat-box .label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 8px;
            color: #a5d6a7;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .main-game {
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.2));
            border-radius: 15px;
            padding: 25px;
            border: 2px solid var(--accent);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .board-container {
            position: relative;
            margin: 20px auto;
            max-width: 500px;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            background: rgba(76, 175, 80, 0.1);
            padding: 15px;
            border-radius: 12px;
            position: relative;
            width: 100%;
            aspect-ratio: 1;
        }
        
        .tile {
            aspect-ratio: 1;
            background: var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            user-select: none;
        }
        
        .tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(145deg, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }
        
        .tile:hover {
            transform: scale(1.08);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
            z-index: 2;
        }
        
        .tile:active {
            transform: scale(0.98);
        }
        
        .tile.empty { 
            background: #2e7d32;
            opacity: 0.6;
        }
        .tile.water { 
            background: linear-gradient(145deg, #2196f3, #1976d2);
            animation: float 3s ease-in-out infinite;
        }
        .tile.sun { 
            background: linear-gradient(145deg, #ff9800, #f57c00);
            animation: pulse 2s ease-in-out infinite;
        }
        .tile.native { 
            background: linear-gradient(145deg, #388e3c, #2e7d32);
        }
        .tile.path { 
            background: linear-gradient(145deg, #8bc34a, #7cb342);
            font-size: 1.3em;
        }
        .tile.bridge { 
            background: linear-gradient(145deg, #795548, #5d4037);
            font-size: 1.3em;
        }
        .tile.weed { 
            background: linear-gradient(145deg, #d32f2f, #c62828);
            animation: shake 0.5s ease-in-out infinite alternate;
        }
        .tile.selected {
            box-shadow: 0 0 0 4px var(--highlight), 0 0 30px rgba(255, 235, 59, 0.8);
            z-index: 10;
            animation: selected-pulse 1.5s ease-in-out infinite;
        }
        
        .tile.connected-plant {
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.5),
                0 0 0 3px #ffeb3b,
                0 0 20px rgba(255, 235, 59, 0.7);
            animation: glow-plant 2s ease-in-out infinite alternate;
        }
        
        .tile.connected-resource {
            animation: pulse-resource 1.5s ease-in-out infinite;
        }
        
        .tile.fully-connected {
            box-shadow: 
                inset 0 0 30px rgba(255, 255, 255, 0.7),
                0 0 0 4px #4caf50,
                0 0 25px rgba(76, 175, 80, 0.8);
            animation: fully-connected-glow 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes shake {
            0% { transform: rotate(-1deg); }
            100% { transform: rotate(1deg); }
        }
        
        @keyframes selected-pulse {
            0%, 100% { box-shadow: 0 0 0 3px var(--highlight), 0 0 20px rgba(255, 235, 59, 0.6); }
            50% { box-shadow: 0 0 0 4px var(--highlight), 0 0 40px rgba(255, 235, 59, 1); }
        }
        
        @keyframes glow-plant {
            0% { box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.5),
                0 0 0 3px #ffeb3b,
                0 0 20px rgba(255, 235, 59, 0.5); }
            100% { box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.7),
                0 0 0 3px #ffeb3b,
                0 0 30px rgba(255, 235, 59, 0.9); }
        }
        
        @keyframes pulse-resource {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes fully-connected-glow {
            0% { box-shadow: 
                inset 0 0 25px rgba(255, 255, 255, 0.6),
                0 0 0 3px #4caf50,
                0 0 20px rgba(76, 175, 80, 0.7); }
            100% { box-shadow: 
                inset 0 0 35px rgba(255, 255, 255, 0.8),
                0 0 0 4px #4caf50,
                0 0 30px rgba(76, 175, 80, 0.9); }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        /* Connection visualization */
        .connection-line {
            position: absolute;
            background: var(--highlight);
            height: 6px;
            border-radius: 3px;
            pointer-events: none;
            z-index: 1;
            transform-origin: 0 0;
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.8);
            opacity: 0;
            animation: line-appear 0.3s forwards;
        }
        
        @keyframes line-appear {
            to { opacity: 0.9; }
        }
        
        .connection-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--highlight);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
            animation: pulse-dot 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(255, 235, 59, 0.8);
        }
        
        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }
        
        /* Plant status indicator */
        .plant-status {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6em;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            font-weight: bold;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 25px;
        }
        
        button {
            background: linear-gradient(145deg, var(--accent), #388e3c);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            min-height: 60px;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(76, 175, 80, 0.4);
        }
        
        button:active {
            transform: translateY(-1px);
        }
        
        button:disabled {
            background: linear-gradient(145deg, #666, #555);
            cursor: not-allowed;
            transform: none !important;
            opacity: 0.6;
        }
        
        button.tool-btn {
            background: linear-gradient(145deg, var(--warning), #f57c00);
        }
        
        button.tool-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #ffb74d, #ff9800);
        }
        
        .cooldown-display {
            font-size: 0.8em;
            color: var(--warning);
            margin-top: 4px;
        }
        
        .resource-counts {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .resource-count {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 12px 20px;
            border-radius: 25px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            font-size: 1.2em;
            font-weight: bold;
            transition: transform 0.3s;
        }
        
        .resource-count:hover {
            transform: scale(1.05);
        }
        
        .sidebar {
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.2));
            border-radius: 15px;
            padding: 25px;
            border: 2px solid var(--accent);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .sidebar-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid;
            transition: transform 0.3s;
        }
        
        .sidebar-section:hover {
            transform: translateX(5px);
        }
        
        .sidebar-section h3 {
            font-size: 1.3em;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .instructions {
            border-color: var(--accent);
        }
        
        .instructions h3 {
            color: #81c784;
        }
        
        .instructions ul {
            padding-left: 20px;
            line-height: 1.7;
        }
        
        .instructions li {
            margin-bottom: 8px;
            padding-left: 5px;
        }
        
        .species-list {
            border-color: var(--warning);
        }
        
        .species-list h3 {
            color: #ffb74d;
        }
        
        .species-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .species-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(5px);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .species-name {
            font-weight: bold;
            color: #a5d6a7;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .species-needs {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
        }
        
        .species-desc {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }
        
        .message-box {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, rgba(200, 230, 201, 0.95), rgba(165, 214, 167, 0.95));
            color: var(--text-dark);
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            z-index: 1000;
            max-width: 90%;
            text-align: center;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 2px solid var(--accent);
            opacity: 0;
            transform: translateX(-50%) translateY(100px);
        }
        
        .message-box.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        .message-box.warning {
            background: linear-gradient(145deg, rgba(255, 205, 210, 0.95), rgba(239, 154, 154, 0.95));
            border-color: var(--danger);
        }
        
        .message-box.success {
            background: linear-gradient(145deg, rgba(200, 230, 201, 0.95), rgba(129, 199, 132, 0.95));
            border-color: var(--accent);
        }
        
        .health-bar {
            width: 100%;
            height: 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .health-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            background: linear-gradient(90deg, 
                #d32f2f 0%, 
                #f44336 30%, 
                #ff9800 50%, 
                #8bc34a 70%, 
                #4caf50 100%);
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .level-up-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(0,0,0,0.95), rgba(26,60,39,0.98));
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            text-align: center;
            animation: fadeIn 0.5s;
        }
        
        .level-up-content {
            background: linear-gradient(145deg, var(--secondary), var(--primary));
            padding: 50px;
            border-radius: 25px;
            border: 3px solid var(--highlight);
            max-width: 600px;
            width: 90%;
            animation: popIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .sound-control {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            border: 2px solid var(--accent);
            font-size: 1.8em;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .sound-control:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.1) rotate(15deg);
            box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
        }
        
        .stats-summary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 30px;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: var(--highlight);
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="sound-control" id="sound-toggle" onclick="toggleSound()">
        <span id="sound-icon">üîä</span>
    </div>
    
    <div class="container">
        <div class="game-header">
            <div>
                <h1 class="game-title">üåø Tassie Tangle</h1>
                <div style="font-size:0.9em; opacity:0.8; margin-top:5px;">
                    Restore Tasmania's native ecosystem
                </div>
            </div>
            <div class="stats">
                <div class="stat-box">
                    <div class="label">Level</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat-box">
                    <div class="label">Total Score</div>
                    <div class="stat-value" id="total-score-value">0</div>
                </div>
                <div class="stat-box">
                    <div class="label">Health</div>
                    <div class="stat-value" id="score">0%</div>
                    <div class="health-bar">
                        <div class="health-fill" id="health-bar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-box">
                    <div class="label">Turn</div>
                    <div class="stat-value" id="turn-count">1</div>
                    <div style="font-size:0.8em; opacity:0.7;">/<span id="max-turns">20</span></div>
                </div>
            </div>
        </div>
        
        <div class="main-game">
            <div class="board-container">
                <div class="board" id="board">
                    <!-- Board tiles will be generated here -->
                </div>
            </div>
            
            <div class="resource-counts">
                <div class="resource-count">
                    <span style="font-size:1.5em;">üíß</span>
                    <span id="water-count">0</span>
                </div>
                <div class="resource-count">
                    <span style="font-size:1.5em;">‚òÄÔ∏è</span>
                    <span id="sun-count">0</span>
                </div>
                <div class="resource-count">
                    <span style="font-size:1.5em;">üåø</span>
                    <span id="plant-count">0</span>
                </div>
                <div class="resource-count">
                    <span style="font-size:1.5em;">üî•</span>
                    <span id="weed-count">0</span>
                </div>
            </div>
            
            <div class="controls">
                <button onclick="useTool('bridge')" class="tool-btn" id="bridge-btn">
                    <span style="font-size:1.3em;">üåâ</span>
                    <div>
                        <div>Build Bridge</div>
                        <div class="cooldown-display" id="bridge-cooldown"></div>
                    </div>
                </button>
                <button onclick="useTool('clear')" class="tool-btn" id="clear-btn">
                    <span style="font-size:1.3em;">üóëÔ∏è</span>
                    <div>
                        <div>Clear Weeds</div>
                        <div class="cooldown-display" id="clear-cooldown"></div>
                    </div>
                </button>
                <button onclick="endTurn()">
                    <span style="font-size:1.3em;">‚è≠Ô∏è</span>
                    <div>
                        <div>End Turn</div>
                        <div style="font-size:0.8em; opacity:0.8;">Events occur</div>
                    </div>
                </button>
                <button onclick="resetGame()" style="background:linear-gradient(145deg, var(--danger), #b71c1c);">
                    <span style="font-size:1.3em;">üîÑ</span>
                    <div>
                        <div>Reset</div>
                        <div style="font-size:0.8em; opacity:0.8;">Current level</div>
                    </div>
                </button>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="sidebar-section instructions">
                <h3><span>üéÆ</span> How to Play</h3>
                <ul>
                    <li><strong>Click plants</strong> (üåøüå∏üå≤üçÇ) to select them</li>
                    <li><strong>Click resources</strong> (üíß/‚òÄÔ∏è) to connect</li>
                    <li>Each plant needs specific resources</li>
                    <li><strong>Use tools</strong> to remove obstacles</li>
                    <li><strong>Connect all plants</strong> before turns run out!</li>
                    <li><strong>Pro tip:</strong> Bridges can connect through multiple obstacles</li>
                    <li><strong>Visual cues:</strong> Yellow lines = connections, ‚úì = plant satisfied</li>
                </ul>
            </div>
            
            <div class="sidebar-section species-list">
                <h3><span>üå±</span> Native Species</h3>
                <div id="species-list">
                    <!-- Species cards will be generated here -->
                </div>
            </div>
            
            <div class="stats-summary">
                <div class="stat-item">
                    <div class="stat-number" id="connected-plants">0</div>
                    <div class="stat-label">Connected Plants</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="total-plants">0</div>
                    <div class="stat-label">Total Plants</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="paths-built">0</div>
                    <div class="stat-label">Paths Built</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="bridges-built">0</div>
                    <div class="stat-label">Bridges Built</div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="level-up-screen" class="level-up-screen">
        <div class="level-up-content">
            <h2 style="font-size:3.5em; color:var(--highlight); margin-bottom:20px;">LEVEL COMPLETE! üéâ</h2>
            <div style="font-size:1.8em; margin:25px 0; color:#ffffff;">
                You restored the ecosystem in <span id="completed-level">1</span>
            </div>
            <div style="font-size:1.2em; margin:20px 0;">
                Level Score: <span id="level-score" style="color:var(--highlight);font-weight:bold;">0</span>
            </div>
            <div style="font-size:1.2em; margin:20px 0;">
                Total Score: <span id="new-total-score" style="color:#4caf50;font-weight:bold;">0</span>
            </div>
            <button onclick="startNextLevel()" style="font-size:1.2em;padding:15px 40px;margin-top:20px;">
                Start Level <span id="next-level">2</span> ‚Üí
            </button>
        </div>
    </div>
    
    <div id="message" class="message-box">
        Welcome to Tasmanian Ecosystem! Select a plant to begin.
    </div>

<script>
    // ================
    // GAME CONFIG
    // ================
    const BOARD_SIZE = 8;
    const BASE_TURNS = 20;
    const SPECIES = [
        { 
            emoji: 'üåø', 
            name: 'Tasmanian Blue Gum', 
            needs: ['water'], 
            desc: 'Iconic tree that koalas depend on',
            rarity: 1,
            points: 10
        },
        { 
            emoji: 'üå∏', 
            name: 'Leatherwood', 
            needs: ['water', 'sun'], 
            desc: 'Vital for native honey production',
            rarity: 2,
            points: 20
        },
        { 
            emoji: 'üå≤', 
            name: 'Huon Pine', 
            needs: ['water'], 
            desc: 'One of the oldest living tree species',
            rarity: 3,
            points: 15
        },
        { 
            emoji: 'üçÇ', 
            name: 'Waratah', 
            needs: ['sun'], 
            desc: 'Tasmania\'s floral emblem',
            rarity: 1,
            points: 10
        }
    ];
    
    const THREATS = [
        { emoji: 'üî•', name: 'Bushfire', effect: 'Destroys paths and plants' },
        { emoji: 'ü¶ä', name: 'Fox', effect: 'Eats native animals' },
        { emoji: 'üåæ', name: 'Gorse', effect: 'Invasive weed that spreads fast' }
    ];

    // ================
    // SOUND SYSTEM
    // ================
    let soundEnabled = true;
    let audioContext;
    let gainNode;
    let connectionLines = [];

    function initAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
            gainNode.gain.value = 0.3;
        } catch (e) {
            console.log("Web Audio API not supported");
            soundEnabled = false;
            document.getElementById('sound-toggle').style.display = 'none';
        }
    }

    function playSound(type) {
        if (!soundEnabled || !audioContext) return;
        
        const oscillator = audioContext.createOscillator();
        const envelope = audioContext.createGain();
        
        oscillator.connect(envelope);
        envelope.connect(gainNode);
        
        oscillator.type = 'square';
        
        switch(type) {
            case 'select':
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.3, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
                break;
                
            case 'connect':
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.4, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
                
                setTimeout(() => {
                    if (!soundEnabled) return;
                    const osc2 = audioContext.createOscillator();
                    const env2 = audioContext.createGain();
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(830.61, audioContext.currentTime);
                    env2.gain.setValueAtTime(0.2, audioContext.currentTime);
                    env2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    osc2.connect(env2);
                    env2.connect(gainNode);
                    osc2.start();
                    osc2.stop(audioContext.currentTime + 0.2);
                }, 100);
                break;
                
            case 'error':
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.4, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.15);
                
                setTimeout(() => {
                    if (!soundEnabled) return;
                    const osc2 = audioContext.createOscillator();
                    const env2 = audioContext.createGain();
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(174.61, audioContext.currentTime);
                    env2.gain.setValueAtTime(0.3, audioContext.currentTime);
                    env2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    osc2.connect(env2);
                    env2.connect(gainNode);
                    osc2.start();
                    osc2.stop(audioContext.currentTime + 0.1);
                }, 50);
                break;
                
            case 'tool':
                oscillator.frequency.setValueAtTime(392, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.3, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.25);
                break;
                
            case 'level':
                const notes = [523.25, 659.25, 783.99, 1046.50];
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        if (!soundEnabled) return;
                        const osc = audioContext.createOscillator();
                        const env = audioContext.createGain();
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        env.gain.setValueAtTime(0.3, audioContext.currentTime);
                        env.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                        osc.connect(env);
                        env.connect(gainNode);
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.15);
                    }, i * 150);
                });
                break;
                
            case 'weed':
                oscillator.frequency.setValueAtTime(146.83, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.3, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.4);
                break;
        }
    }

    function toggleSound() {
        soundEnabled = !soundEnabled;
        const icon = document.getElementById('sound-icon');
        icon.textContent = soundEnabled ? 'üîä' : 'üîá';
        
        if (soundEnabled && audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        if (soundEnabled) {
            playSound('select');
        }
    }

    // ================
    // CONNECTION VISUALIZATION
    // ================
    function drawConnectionLine(x1, y1, x2, y2) {
        const boardRect = document.getElementById('board').getBoundingClientRect();
        const tileSize = boardRect.width / BOARD_SIZE;
        
        const x1px = (x1 + 0.5) * tileSize;
        const y1px = (y1 + 0.5) * tileSize;
        const x2px = (x2 + 0.5) * tileSize;
        const y2px = (y2 + 0.5) * tileSize;
        
        const line = document.createElement('div');
        line.className = 'connection-line';
        
        const dx = x2px - x1px;
        const dy = y2px - y1px;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        
        line.style.width = `${length}px`;
        line.style.height = '6px';
        line.style.left = `${x1px}px`;
        line.style.top = `${y1px - 3}px`;
        line.style.transform = `rotate(${angle}deg)`;
        line.style.background = '#ffeb3b';
        line.style.opacity = '0.8';
        
        const dot1 = document.createElement('div');
        dot1.className = 'connection-dot';
        dot1.style.left = `${x1px - 6}px`;
        dot1.style.top = `${y1px - 6}px`;
        
        const dot2 = document.createElement('div');
        dot2.className = 'connection-dot';
        dot2.style.left = `${x2px - 6}px`;
        dot2.style.top = `${y2px - 6}px`;
        
        const board = document.getElementById('board');
        board.appendChild(line);
        board.appendChild(dot1);
        board.appendChild(dot2);
        
        connectionLines.push({line, dots: [dot1, dot2]});
    }

    function clearConnectionVisuals() {
        connectionLines.forEach(({line, dots}) => {
            if (line.parentNode) line.parentNode.removeChild(line);
            dots.forEach(dot => {
                if (dot.parentNode) dot.parentNode.removeChild(dot);
            });
        });
        connectionLines = [];
    }

    function updateConnectionVisuals() {
        clearConnectionVisuals();
        
        connections.forEach(conn => {
            const [from, to] = conn.split('-');
            const [x1, y1] = from.split(',').map(Number);
            const [x2, y2] = to.split(',').map(Number);
            
            drawConnectionLine(x1, y1, x2, y2);
        });
        
        updatePlantStatusIndicators();
        updateResourceCounts();
    }

    function updatePlantStatusIndicators() {
        document.querySelectorAll('.plant-status').forEach(el => el.remove());
        
        let connectedPlants = 0;
        let totalPlants = 0;
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'native') {
                    totalPlants++;
                    const species = findSpecies(board[y][x].element.textContent);
                    let needsMet = 0;
                    let waterConnected = false;
                    let sunConnected = false;

                    if (species.needs.includes('water')) {
                        for (let ty = 0; ty < BOARD_SIZE; ty++) {
                            for (let tx = 0; tx < BOARD_SIZE; tx++) {
                                if (board[ty][tx].type === 'water' && isConnected(x, y, tx, ty)) {
                                    waterConnected = true;
                                    needsMet++;
                                    break;
                                }
                            }
                            if (waterConnected) break;
                        }
                    }

                    if (species.needs.includes('sun')) {
                        for (let ty = 0; ty < BOARD_SIZE; ty++) {
                            for (let tx = 0; tx < BOARD_SIZE; tx++) {
                                if (board[ty][tx].type === 'sun' && isConnected(x, y, tx, ty)) {
                                    sunConnected = true;
                                    needsMet++;
                                    break;
                                }
                            }
                            if (sunConnected) break;
                        }
                    }
                    
                    const tile = board[y][x].element;
                    const status = document.createElement('div');
                    status.className = 'plant-status';
                    
                    if (needsMet >= species.needs.length) {
                        connectedPlants++;
                        status.textContent = '‚úì';
                        status.style.color = '#4caf50';
                        status.style.background = 'rgba(76, 175, 80, 0.9)';
                        tile.classList.add('connected-plant');
                        tile.classList.remove('connected');
                    } else if (needsMet > 0) {
                        status.textContent = `${needsMet}/${species.needs.length}`;
                        status.style.color = '#ff9800';
                        status.style.background = 'rgba(255, 152, 0, 0.9)';
                        tile.classList.remove('connected-plant', 'connected');
                    } else {
                        status.textContent = '!';
                        status.style.color = '#f44336';
                        status.style.background = 'rgba(244, 67, 54, 0.9)';
                        tile.classList.remove('connected-plant', 'connected');
                    }
                    
                    tile.appendChild(status);
                    
                    // Update resource connection indicators
                    for (let ty = 0; ty < BOARD_SIZE; ty++) {
                        for (let tx = 0; tx < BOARD_SIZE; tx++) {
                            if ((board[ty][tx].type === 'water' || board[ty][tx].type === 'sun') && 
                                isConnected(x, y, tx, ty)) {
                                board[ty][tx].element.classList.add('connected-resource');
                            } else {
                                board[ty][tx].element.classList.remove('connected-resource');
                            }
                        }
                    }
                }
            }
        }
        
        // Update stats summary
        document.getElementById('connected-plants').textContent = connectedPlants;
        document.getElementById('total-plants').textContent = totalPlants;
    }

    // ================
    // GAME STATE
    // ================
    let board = [];
    let selectedTile = null;
    let score = 0;
    let turn = 1;
    let gameActive = true;
    let discoveredSpecies = [];
    let lastBridgeTurn = -3;
    let lastClearTurn = -5;
    let bridgeCooldown = 0;
    let clearCooldown = 0;
    let connections = [];
    let multiplier = 1;
    let level = 1;
    let totalScore = 0;
    let levelScore = 0;
    let maxTurns = BASE_TURNS;
    let pathsBuilt = 0;
    let bridgesBuilt = 0;

    // ================
    // INITIALIZATION
    // ================
    function initGame() {
        initAudio();
        
        const boardElement = document.getElementById('board');
        boardElement.innerHTML = '';
        board = [];
        selectedTile = null;
        score = 0;
        levelScore = 0;
        turn = 1;
        gameActive = true;
        discoveredSpecies = [];
        lastBridgeTurn = -3;
        lastClearTurn = -5;
        connections = [];
        multiplier = 1;
        pathsBuilt = 0;
        bridgesBuilt = 0;
        
        clearConnectionVisuals();
        
        maxTurns = Math.max(10, BASE_TURNS - Math.floor(level / 2));
        
        updateScore();
        updateTurnCounter();
        updateCooldowns();
        updateLevelDisplay();
        updateTotalScore();
        
        // Create board tiles
        for (let y = 0; y < BOARD_SIZE; y++) {
            board[y] = [];
            for (let x = 0; x < BOARD_SIZE; x++) {
                const tile = document.createElement('div');
                tile.className = 'tile empty';
                tile.dataset.x = x;
                tile.dataset.y = y;
                tile.addEventListener('click', () => handleTileClick(x, y));
                boardElement.appendChild(tile);
                board[y][x] = { 
                    type: 'empty', 
                    element: tile,
                    revealed: false,
                    connected: false,
                    x: x,
                    y: y
                };
            }
        }

        placeWithPathways();
        renderSpeciesList();
        showMessage(`Level ${level}: Connect plants to resources!`, 'info');
        updateResourceCounts();
        updateConnectionVisuals();
        
        setTimeout(() => playSound('select'), 300);
    }

    function placeWithPathways() {
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                board[y][x].type = 'empty';
                board[y][x].element.textContent = '';
                board[y][x].element.className = 'tile empty';
                board[y][x].connected = false;
            }
        }
        
        const resourceClusters = Math.max(2, 4 - Math.floor(level / 3));
        placeCluster('water', 'üíß', resourceClusters, 3);
        placeCluster('sun', '‚òÄÔ∏è', resourceClusters, 3);
        
        const plantsPerSpecies = 1 + Math.floor(level / 2);
        SPECIES.forEach(species => {
            placeNearResource('native', species.emoji, plantsPerSpecies, species.needs[0]);
        });

        const initialWeeds = 3 + level;
        placeRandom('weed', getRandomThreat().emoji, initialWeeds, true);
    }

    function placeCluster(type, emoji, clusters, clusterSize) {
        for (let c = 0; c < clusters; c++) {
            const startX = Math.floor(Math.random() * (BOARD_SIZE - 3)) + 1;
            const startY = Math.floor(Math.random() * (BOARD_SIZE - 3)) + 1;
            
            for (let i = 0; i < clusterSize; i++) {
                const x = startX + Math.floor(Math.random() * 3) - 1;
                const y = startY + Math.floor(Math.random() * 3) - 1;
                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[y][x].type === 'empty') {
                    convertTile(x, y, type, emoji);
                }
            }
        }
    }

    function placeNearResource(type, emoji, count, nearType) {
        let placed = 0;
        const maxAttempts = 50;
        
        for (let attempt = 0; attempt < maxAttempts && placed < count; attempt++) {
            const resources = [];
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (board[y][x].type === nearType) resources.push({x, y});
                }
            }
            
            if (resources.length === 0) break;
            
            const {x: rx, y: ry} = resources[Math.floor(Math.random() * resources.length)];
            
            const directions = [
                {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1},
                {dx:1,dy:1}, {dx:-1,dy:1}, {dx:1,dy:-1}, {dx:-1,dy:-1}
            ].sort(() => Math.random() - 0.5);
            
            for (const dir of directions) {
                const nx = rx + dir.dx;
                const ny = ry + dir.dy;
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                    board[ny][nx].type === 'empty') {
                    convertTile(nx, ny, type, emoji);
                    placed++;
                    break;
                }
            }
        }
        
        if (placed < count) {
            const remaining = count - placed;
            placeRandom(type, emoji, remaining);
            placed += remaining;
        }
    }

    function placeRandom(type, emoji, count, avoidResources = false) {
        const emptyTiles = [];
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'empty') {
                    if (!avoidResources || !isNearResource(x, y)) {
                        emptyTiles.push({x, y});
                    }
                }
            }
        }
        
        shuffleArray(emptyTiles);
        for (let i = 0; i < Math.min(count, emptyTiles.length); i++) {
            const {x, y} = emptyTiles[i];
            convertTile(x, y, type, emoji);
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function isNearResource(x, y) {
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                    if (board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function convertTile(x, y, type, emoji) {
        board[y][x].type = type;
        board[y][x].element.textContent = emoji;
        board[y][x].element.className = `tile ${type}`;
        
        board[y][x].element.querySelectorAll('.plant-status').forEach(el => el.remove());
        board[y][x].element.classList.remove('connected-plant', 'connected-resource', 'fully-connected');
        
        if (type === 'water') {
            board[y][x].element.style.animation = 'float 3s ease-in-out infinite';
        }
        if (type === 'sun') {
            board[y][x].element.style.animation = 'pulse 2s ease-in-out infinite';
        }
        if (type === 'weed') {
            board[y][x].element.style.animation = 'shake 0.5s ease-in-out infinite alternate';
        }
        
        board[y][x].connected = (type === 'path' || type === 'bridge');
    }

    // ================
    // GAME LOGIC
    // ================
    function handleTileClick(x, y) {
        if (!gameActive) return;
        
        const tile = board[y][x];
        const prevSelected = selectedTile;
        
        // If clicking the same tile again, deselect it
        if (selectedTile && selectedTile.x === x && selectedTile.y === y) {
            selectedTile.element.classList.remove('selected');
            selectedTile = null;
            showMessage("Tile deselected.", 'info');
            return;
        }
        
        // If we already have a selected plant AND click on a water/sun resource, try to connect
        if (prevSelected && (tile.type === 'water' || tile.type === 'sun')) {
            // Check if previous selection was a plant
            if (board[prevSelected.y][prevSelected.x].type === 'native') {
                const plantSpecies = findSpecies(board[prevSelected.y][prevSelected.x].element.textContent);
                
                if (plantSpecies.needs.includes(tile.type)) {
                    if (connectTiles(prevSelected.x, prevSelected.y, x, y)) {
                        // Success! Remove selection from plant
                        prevSelected.element.classList.remove('selected');
                        selectedTile = null;
                    }
                    return; // Don't select the resource tile
                } else {
                    playSound('error');
                    const needsStr = plantSpecies.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' and ');
                    showMessage(`This plant doesn't need ${tile.type}! It needs ${needsStr}.`, 'warning');
                    // Keep plant selected
                    return;
                }
            }
        }
        
        // If we already have a selected plant AND click on a bridge, try to connect through bridge
        if (prevSelected && tile.type === 'bridge') {
            if (board[prevSelected.y][prevSelected.x].type === 'native') {
                const success = connectThroughBridge(prevSelected.x, prevSelected.y, x, y);
                if (success) {
                    // Connection successful - keep plant selected for potential more connections
                    // Don't change selection
                    return;
                } else {
                    // Connection failed - keep plant selected
                    selectedTile = prevSelected;
                    selectedTile.element.classList.add('selected');
                    return;
                }
            }
        }
        
        // Clear previous selection
        if (selectedTile) {
            selectedTile.element.classList.remove('selected');
        }
        
        // Select the clicked tile
        selectedTile = { 
            x, y, 
            element: tile.element,
            species: tile.type === 'native' ? findSpecies(tile.element.textContent) : null
        };
        tile.element.classList.add('selected');
        
        // Handle based on tile type
        if (tile.type === 'native') {
            const species = selectedTile.species;
            
            // Check if already fully connected
            let waterConnected = false;
            let sunConnected = false;

            if (species.needs.includes('water')) {
                for (let ty = 0; ty < BOARD_SIZE; ty++) {
                    for (let tx = 0; tx < BOARD_SIZE; tx++) {
                        if (board[ty][tx].type === 'water' && isConnected(x, y, tx, ty)) {
                            waterConnected = true;
                            break;
                        }
                    }
                    if (waterConnected) break;
                }
            } else {
                waterConnected = true; // Doesn't need water
            }

            if (species.needs.includes('sun')) {
                for (let ty = 0; ty < BOARD_SIZE; ty++) {
                    for (let tx = 0; tx < BOARD_SIZE; tx++) {
                        if (board[ty][tx].type === 'sun' && isConnected(x, y, tx, ty)) {
                            sunConnected = true;
                            break;
                        }
                    }
                    if (sunConnected) break;
                }
            } else {
                sunConnected = true; // Doesn't need sun
            }

            const isFullyConnected = (!species.needs.includes('water') || waterConnected) && 
                                     (!species.needs.includes('sun') || sunConnected);        
            
            if (isFullyConnected) {
                playSound('error');
                showMessage("This plant is already fully connected! Try another plant.", 'warning');
            } else {
                playSound('select');
                const speciesName = species.name;
                if (!discoveredSpecies.includes(speciesName)) {
                    discoveredSpecies.push(speciesName);
                    renderSpeciesList();
                    showMessage(`Discovered: ${speciesName}! ${species.desc}`, 'success');
                } else {
                    const needsStr = species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' and ');
                    showMessage(`Selected: ${speciesName}. Needs: ${needsStr}.`, 'info');
                }
            }
        } 
        else if (tile.type === 'water' || tile.type === 'sun') {
            // If we get here, it means we selected a resource without a plant selected first
            showMessage(`Selected ${tile.type} source. Now select a plant that needs it.`, 'info');
        }
        else if (tile.type === 'bridge') {
            showMessage(`Selected bridge. Now select a plant to connect through it.`, 'info');
        }
        else if (tile.type === 'empty') {
            showMessage(`Selected empty tile. Use Bridge tool here to build a bridge.`, 'info');
        }
        else if (tile.type === 'weed') {
            showMessage(`Selected weed tile. Use Clear Weeds tool to remove it.`, 'warning');
        }
        else if (tile.type === 'path') {
            showMessage(`Selected path tile.`, 'info');
        }
    }
    
    function connectTiles(x1, y1, x2, y2) {
        const path = findConnectionPath(x1, y1, x2, y2);
        if (!path) {
            playSound('error');
            showMessage("Cannot connect these tiles! Path is blocked.", 'warning');
            return false;
        }

        const connectionKey = `${x1},${y1}-${x2},${y2}`;
        const reverseKey = `${x2},${y2}-${x1},${y1}`;
        if (connections.includes(connectionKey) || connections.includes(reverseKey)) {
            playSound('error');
            showMessage("These are already connected!", 'warning');
            return false;
        }

        connections.push(connectionKey);

        path.forEach(({x, y}, i) => {
            setTimeout(() => {
                if (board[y][x].type === 'empty') {
                    convertTile(x, y, 'path', 'üå±');
                    pathsBuilt++;
                }
            }, i * 100);
        });

        setTimeout(() => {
            board[y1][x1].connected = true;
            board[y2][x2].connected = true;
            
            checkPlantNeeds(x1, y1);
            
            updateConnectionVisuals();
            document.getElementById('paths-built').textContent = pathsBuilt;
            
            playSound('connect');
            showMessage("üå± Connection successful!", 'success');
            checkGameState();
        }, path.length * 100 + 200);

        return true;
    }

    function findConnectionPath(x1, y1, x2, y2) {
        if (y1 === y2) {
            const path = getStraightPath(x1, y1, x2, y2, true);
            if (path) return path;
        }
        
        if (x1 === x2) {
            const path = getStraightPath(x1, y1, x2, y2, false);
            if (path) return path;
        }
        
        const path1 = getLShapedPath(x1, y1, x2, y2, true);
        if (path1) return path1;
        
        const path2 = getLShapedPath(x1, y1, x2, y2, false);
        if (path2) return path2;
        
        return null;
    }

    function getStraightPath(x1, y1, x2, y2, isHorizontal) {
        const path = [];
        
        if (isHorizontal) {
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);
            const y = y1;
            
            for (let x = startX + 1; x < endX; x++) {
                if (!isTilePassable(x, y, true)) return null;
                path.push({x, y});
            }
        } else {
            const startY = Math.min(y1, y2);
            const endY = Math.max(y1, y2);
            const x = x1;
            
            for (let y = startY + 1; y < endY; y++) {
                if (!isTilePassable(x, y, true)) return null;
                path.push({x, y});
            }
        }
        
        return path;
    }

    function getLShapedPath(x1, y1, x2, y2, horizontalFirst) {
        const path = [];
        let cornerX, cornerY;
        
        if (horizontalFirst) {
            cornerX = x2;
            cornerY = y1;
            
            const hStartX = Math.min(x1, cornerX);
            const hEndX = Math.max(x1, cornerX);
            for (let x = hStartX + 1; x < hEndX; x++) {
                if (!isTilePassable(x, cornerY, true)) return null;
                path.push({x, y: cornerY});
            }
            
            const vStartY = Math.min(cornerY, y2);
            const vEndY = Math.max(cornerY, y2);
            for (let y = vStartY + 1; y < vEndY; y++) {
                if (!isTilePassable(cornerX, y, true)) return null;
                path.push({x: cornerX, y});
            }
        } else {
            cornerX = x1;
            cornerY = y2;
            
            const vStartY = Math.min(y1, cornerY);
            const vEndY = Math.max(y1, cornerY);
            for (let y = vStartY + 1; y < vEndY; y++) {
                if (!isTilePassable(cornerX, y, true)) return null;
                path.push({x: cornerX, y});
            }
            
            const hStartX = Math.min(cornerX, x2);
            const hEndX = Math.max(cornerX, x2);
            for (let x = hStartX + 1; x < hEndX; x++) {
                if (!isTilePassable(x, cornerY, true)) return null;
                path.push({x, y: cornerY});
            }
        }
        
        return path;
    }

    function isTilePassable(x, y, forPath) {
        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return false;
        
        const tileType = board[y][x].type;
        
        if (forPath) {
            return tileType === 'empty' || tileType === 'path' || tileType === 'bridge';
        }
        
        return tileType === 'empty';
    }

    function connectThroughBridge(x1, y1, x2, y2) {
        // x1, y1 should be the plant coordinates, x2, y2 should be the bridge coordinates
        // Check if the source is actually a plant
        if (board[y1][x1].type !== 'native') {
            showMessage("Select a plant first, then click a bridge!", 'warning');
            return false;
        }
        
        // Check if the destination is actually a bridge
        if (board[y2][x2].type !== 'bridge') {
            showMessage("This is not a bridge!", 'warning');
            return false;
        }
        
        // Find a resource connected to this bridge
        let resourceTile = null;
        const directions = [
            {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
        ];
        
        // First, check if bridge is already connected to a resource
        for (const dir of directions) {
            const nx = x2 + dir.dx;
            const ny = y2 + dir.dy;
            if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                if (board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
                    resourceTile = {x: nx, y: ny, type: board[ny][nx].type};
                    break;
                }
            }
        }
        
        // If not directly adjacent, check if bridge is connected to a path that leads to a resource
        if (!resourceTile) {
            // We need to find any resource that's connected to this bridge
            for (let ty = 0; ty < BOARD_SIZE; ty++) {
                for (let tx = 0; tx < BOARD_SIZE; tx++) {
                    if ((board[ty][tx].type === 'water' || board[ty][tx].type === 'sun') && 
                        isConnected(x2, y2, tx, ty)) {
                        resourceTile = {x: tx, y: ty, type: board[ty][tx].type};
                        break;
                    }
                }
                if (resourceTile) break;
            }
        }
        
        if (!resourceTile) {
            showMessage("This bridge isn't connected to any resource!", 'warning');
            return false;
        }
        
        // Check if the plant needs this type of resource
        const plantSpecies = findSpecies(board[y1][x1].element.textContent);
        if (!plantSpecies.needs.includes(resourceTile.type)) {
            const needsStr = plantSpecies.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' and ');
            showMessage(`This plant doesn't need ${resourceTile.type}! It needs ${needsStr}.`, 'warning');
            return false;
        }
        
        // Check if plant is already connected to this resource
        if (isConnected(x1, y1, resourceTile.x, resourceTile.y)) {
            showMessage("This plant is already connected to that resource!", 'warning');
            return false;
        }
        
        // Find paths from plant to bridge and from bridge to resource
        const path1 = findConnectionPath(x1, y1, x2, y2);
        const path2 = findConnectionPath(x2, y2, resourceTile.x, resourceTile.y);
        
        if (path1 && path2) {
            const connectionKey = `${x1},${y1}-${resourceTile.x},${resourceTile.y}`;
            const reverseKey = `${resourceTile.x},${resourceTile.y}-${x1},${y1}`;
            
            if (connections.includes(connectionKey) || connections.includes(reverseKey)) {
                playSound('error');
                showMessage("These are already connected!", 'warning');
                return false;
            }
            
            connections.push(connectionKey);
            
            // Create path from plant to bridge
            path1.forEach(({x, y}, i) => {
                setTimeout(() => {
                    if (board[y][x].type === 'empty') {
                        convertTile(x, y, 'path', 'üå±');
                        pathsBuilt++;
                    }
                }, i * 100);
            });
            
            // Create path from bridge to resource
            path2.forEach(({x, y}, i) => {
                setTimeout(() => {
                    if (board[y][x].type === 'empty') {
                        convertTile(x, y, 'path', 'üå±');
                        pathsBuilt++;
                    }
                }, (path1.length + i) * 100);
            });
            
            setTimeout(() => {
                board[y1][x1].connected = true;
                board[resourceTile.y][resourceTile.x].connected = true;
                
                checkPlantNeeds(x1, y1);
                showMessage("Connected through bridge!", 'success');
                updateConnectionVisuals();
                document.getElementById('paths-built').textContent = pathsBuilt;
                checkGameState();
                playSound('connect');
            }, (path1.length + path2.length) * 100 + 200);
            
            return true;
        }
        
        showMessage("Cannot connect through this bridge! Path is blocked.", 'warning');
        return false;
    }
    
    function checkPlantNeeds(x, y) {
        if (board[y][x].type !== 'native') return;
        
        const species = findSpecies(board[y][x].element.textContent);
        let waterConnected = false;
        let sunConnected = false;
        
        if (species.needs.includes('water')) {
            for (let ty = 0; ty < BOARD_SIZE; ty++) {
                for (let tx = 0; tx < BOARD_SIZE; tx++) {
                    if (board[ty][tx].type === 'water' && isConnected(x, y, tx, ty)) {
                        waterConnected = true;
                        break;
                    }
                }
                if (waterConnected) break;
            }
        }
        
        if (species.needs.includes('sun')) {
            for (let ty = 0; ty < BOARD_SIZE; ty++) {
                for (let tx = 0; tx < BOARD_SIZE; tx++) {
                    if (board[ty][tx].type === 'sun' && isConnected(x, y, tx, ty)) {
                        sunConnected = true;
                        break;
                    }
                }
                if (sunConnected) break;
            }
        }
        
        // Only award points if ALL needs are met
        const needsMet = (!species.needs.includes('water') || waterConnected) && 
                         (!species.needs.includes('sun') || sunConnected);
        
        if (needsMet && !board[y][x].element.classList.contains('fully-connected')) {
            board[y][x].element.classList.add('fully-connected');
            multiplier += 0.2;
            const pointsEarned = Math.floor(species.points * multiplier);
            levelScore += pointsEarned;
            totalScore += pointsEarned;
            updateTotalScore();
            updateScore();
            showMessage(`Great job! ${species.name} is thriving! +${pointsEarned} points (x${multiplier.toFixed(1)})`, 'success');
        }
        
        updateConnectionVisuals();
    }
    
    function useTool(toolType) {
        if (!selectedTile) {
            playSound('error');
            showMessage("Select a tile first!", 'warning');
            return;
        }

        const {x, y} = selectedTile;
        
        switch(toolType) {
            case 'bridge':
                if (turn - lastBridgeTurn < 3) {
                    playSound('error');
                    showMessage(`Bridge on cooldown! Wait ${3 - (turn - lastBridgeTurn)} more turns.`, 'warning');
                    return;
                }
                if (board[y][x].type !== 'empty') {
                    playSound('error');
                    showMessage("Can only build bridges on empty tiles!", 'warning');
                    return;
                }
                convertTile(x, y, 'bridge', 'üåâ');
                lastBridgeTurn = turn;
                bridgesBuilt++;
                updateCooldowns();
                playSound('tool');
                showMessage("Built a bridge! Now connect plants through it.", 'success');
                document.getElementById('bridges-built').textContent = bridgesBuilt;
                break;
                
            case 'clear':
                if (turn - lastClearTurn < 5) {
                    playSound('error');
                    showMessage(`Weed clearing on cooldown! Wait ${5 - (turn - lastClearTurn)} more turns.`, 'warning');
                    return;
                }
                if (board[y][x].type !== 'weed') {
                    playSound('error');
                    showMessage("Can only clear weed tiles!", 'warning');
                    return;
                }
                convertTile(x, y, 'empty', '');
                lastClearTurn = turn;
                updateCooldowns();
                playSound('tool');
                showMessage("Cleared weeds! Native plants can grow here now.", 'success');
                break;
        }
        
        selectedTile.element.classList.remove('selected');
        selectedTile = null;
        updateConnectionVisuals();
    }

    function endTurn() {
        if (!gameActive) return;
        
        turn++;
        updateTurnCounter();
        updateCooldowns();
        
        const weedSpreadRate = Math.min(0.2 + (level / 10) + (turn / 40), 0.7);
        spreadWeeds(weedSpreadRate);
        
        if (turn > 3 && Math.random() < 0.3 + (level * 0.02)) triggerRandomEvent();
        
        checkGameState();
        
        if (turn % Math.max(1, 4 - Math.floor(level / 5)) === 0) respawnResources();
        
        showMessage(`Turn ${turn} started. Connect more plants!`, 'info');
        playSound('select');
    }

    function spreadWeeds(spreadRate) {
        const newWeeds = [];
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'weed' && Math.random() < spreadRate) {
                    const directions = [
                        {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
                    ].sort(() => Math.random() - 0.5);
                    
                    for (const dir of directions) {
                        const nx = x + dir.dx;
                        const ny = y + dir.dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                            board[ny][nx].type === 'empty') {
                            newWeeds.push({x: nx, y: ny});
                            break;
                        }
                    }
                }
            }
        }
        
        if (newWeeds.length > 0) {
            showMessage(`‚ö†Ô∏è Weeds spread to ${newWeeds.length} new areas!`, 'warning');
            newWeeds.forEach(({x, y}) => {
                convertTile(x, y, 'weed', getRandomThreat().emoji);
            });
        }
        
        updateConnectionVisuals();
    }

    function respawnResources() {
        const emptyTiles = getEmptyTiles();
        if (emptyTiles.length === 0) return;
        
        const waterCount = countResources('water');
        const sunCount = countResources('sun');
        const respawnType = waterCount <= sunCount ? 'water' : 'sun';
        
        let placed = false;
        const resources = [];
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === respawnType) resources.push({x, y});
            }
        }
        
        if (resources.length > 0) {
            const {x: rx, y: ry} = resources[Math.floor(Math.random() * resources.length)];
            const directions = [
                {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
            ].sort(() => Math.random() - 0.5);
            
            for (const dir of directions) {
                const nx = rx + dir.dx;
                const ny = ry + dir.dy;
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                    board[ny][nx].type === 'empty') {
                    convertTile(nx, ny, respawnType, respawnType === 'water' ? 'üíß' : '‚òÄÔ∏è');
                    placed = true;
                    break;
                }
            }
        }
        
        if (!placed) {
            const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            convertTile(x, y, respawnType, respawnType === 'water' ? 'üíß' : '‚òÄÔ∏è');
        }
        
        showMessage(`A new ${respawnType} source emerged!`, 'success');
        updateResourceCounts();
        updateConnectionVisuals();
    }

    function triggerRandomEvent() {
        const events = [
            { 
                name: 'Rainfall', 
                effect: () => {
                    const emptyTiles = getEmptyTiles();
                    if (emptyTiles.length > 0) {
                        const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                        convertTile(x, y, 'water', 'üíß');
                        showMessage("üåßÔ∏è Rainfall created a new water source!", 'success');
                        updateResourceCounts();
                    }
                },
                chance: 0.5
            },
            {
                name: 'Drought',
                effect: () => {
                    const waterTiles = [];
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x].type === 'water') waterTiles.push({x, y});
                        }
                    }
                    if (waterTiles.length > 1) {
                        const {x, y} = waterTiles[Math.floor(Math.random() * waterTiles.length)];
                        convertTile(x, y, 'empty', '');
                        showMessage("‚òÄÔ∏è Drought dried up a water source!", 'warning');
                        updateResourceCounts();
                    }
                },
                chance: 0.3
            },
            {
                name: 'Sunny Break',
                effect: () => {
                    const emptyTiles = getEmptyTiles();
                    if (emptyTiles.length > 0) {
                        const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                        convertTile(x, y, 'sun', '‚òÄÔ∏è');
                        showMessage("‚òÄÔ∏è Sunshine created a new sunny patch!", 'success');
                        updateResourceCounts();
                    }
                },
                chance: 0.5
            },
            {
                name: 'Wildfire',
                effect: () => {
                    const destroyChance = 0.2 + (level * 0.02);
                    let pathsDestroyed = 0;
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x].type === 'path' && Math.random() < destroyChance) {
                                convertTile(x, y, 'empty', '');
                                pathsDestroyed++;
                                pathsBuilt = Math.max(0, pathsBuilt - 1);
                            }
                        }
                    }
                    showMessage(`üî• Wildfire destroyed ${pathsDestroyed} paths!`, 'warning');
                    document.getElementById('paths-built').textContent = pathsBuilt;
                    checkGameState();
                },
                chance: 0.2
            },
            {
                name: 'Invasive Species',
                effect: () => {
                    const newWeeds = 1 + Math.floor(level / 2);
                    placeRandom('weed', getRandomThreat().emoji, newWeeds);
                    showMessage(`‚ö†Ô∏è Invasive species spread ${newWeeds} new weeds!`, 'warning');
                },
                chance: 0.3
            }
        ];
        
        let total = 0;
        const randomValue = Math.random();
        let selectedEvent = events[0];
        
        for (const event of events) {
            total += event.chance;
            if (randomValue <= total) {
                selectedEvent = event;
                break;
            }
        }
        
        selectedEvent.effect();
        updateConnectionVisuals();
    }

    function checkGameState() {
        let connectedPlants = 0;
        let totalPlants = 0;
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'native') {
                    totalPlants++;
                    const species = findSpecies(board[y][x].element.textContent);
                    let waterConnected = false;
                    let sunConnected = false;
                    
                    // Check water connection if needed
                    if (species.needs.includes('water')) {
                        for (let ty = 0; ty < BOARD_SIZE; ty++) {
                            for (let tx = 0; tx < BOARD_SIZE; tx++) {
                                if (board[ty][tx].type === 'water' && isConnected(x, y, tx, ty)) {
                                    waterConnected = true;
                                    break;
                                }
                            }
                            if (waterConnected) break;
                        }
                    } else {
                        waterConnected = true; // Doesn't need water, so consider it "connected"
                    }
                    
                    // Check sun connection if needed
                    if (species.needs.includes('sun')) {
                        for (let ty = 0; ty < BOARD_SIZE; ty++) {
                            for (let tx = 0; tx < BOARD_SIZE; tx++) {
                                if (board[ty][tx].type === 'sun' && isConnected(x, y, tx, ty)) {
                                    sunConnected = true;
                                    break;
                                }
                            }
                            if (sunConnected) break;
                        }
                    } else {
                        sunConnected = true; // Doesn't need sun, so consider it "connected"
                    }
                    
                    // Plant is fully connected only if ALL its needs are met
                    if ((!species.needs.includes('water') || waterConnected) && 
                        (!species.needs.includes('sun') || sunConnected)) {
                        connectedPlants++;
                    }
                }
            }
        }
        
        const newScore = totalPlants > 0 ? Math.floor((connectedPlants / totalPlants) * 100) : 0;
        if (newScore !== score) {
            score = newScore;
            updateScore();
        }
        
        if (score === 100) {
            gameActive = false;
            levelComplete();
        } else if (turn >= maxTurns) {
            gameActive = false;
            showMessage(`üíÄ Time's up! You restored ${score}% of the ecosystem. Total Score: ${totalScore}`, 'warning');
        }
        
        updateConnectionVisuals();
    }
    
    function isConnected(x1, y1, x2, y2) {
        if (x1 === x2 && y1 === y2) return true;
        
        const visited = new Set();
        const queue = [{x: x1, y: y1}];
        visited.add(`${x1},${y1}`);
        
        while (queue.length > 0) {
            const {x, y} = queue.shift();
            
            const directions = [
                {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
            ];
            
            for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                const key = `${nx},${ny}`;
                
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && !visited.has(key)) {
                    if (nx === x2 && ny === y2) {
                        return true;
                    }
                    
                    const tileType = board[ny][nx].type;
                    if (tileType === 'path' || tileType === 'bridge' || tileType === 'water' || tileType === 'sun' ||
                        (nx === x1 && ny === y1) || (nx === x2 && ny === y2)) {
                        visited.add(key);
                        queue.push({x: nx, y: ny});
                    }
                }
            }
        }
        
        return false;
    }

    function levelComplete() {
        const bonusPoints = (maxTurns - turn) * 5 * level;
        levelScore += bonusPoints;
        totalScore += levelScore;
        
        playSound('level');
        
        document.getElementById('completed-level').textContent = level;
        document.getElementById('level-score').textContent = levelScore;
        document.getElementById('new-total-score').textContent = totalScore;
        document.getElementById('next-level').textContent = level + 1;
        document.getElementById('level-up-screen').style.display = 'flex';
    }

    function startNextLevel() {
        level++;
        document.getElementById('level-up-screen').style.display = 'none';
        initGame();
    }

    // ================
    // UI UPDATES
    // ================
    function renderSpeciesList() {
        const list = document.getElementById('species-list');
        list.innerHTML = '';
        
        SPECIES.forEach(species => {
            const card = document.createElement('div');
            card.className = `species-card ${discoveredSpecies.includes(species.name) ? 'discovered' : ''}`;
            card.innerHTML = `
                <div class="species-name">${species.emoji} ${species.name}</div>
                <div class="species-needs">Needs: ${species.needs.map(n => 
                    n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' + ')}</div>
                <div class="species-desc">${discoveredSpecies.includes(species.name) ? 
                    species.desc : 'Not discovered yet'}</div>
            `;
            list.appendChild(card);
        });
    }

    function updateResourceCounts() {
        let waterCount = 0;
        let sunCount = 0;
        let plantCount = 0;
        let weedCount = 0;
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                switch(board[y][x].type) {
                    case 'water': waterCount++; break;
                    case 'sun': sunCount++; break;
                    case 'native': plantCount++; break;
                    case 'weed': weedCount++; break;
                }
            }
        }
        
        document.getElementById('water-count').textContent = waterCount;
        document.getElementById('sun-count').textContent = sunCount;
        document.getElementById('plant-count').textContent = plantCount;
        document.getElementById('weed-count').textContent = weedCount;
    }

    function countResources(type) {
        let count = 0;
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === type) count++;
            }
        }
        return count;
    }

    function updateScore() {
        document.getElementById('score').textContent = score + '%';
        document.getElementById('health-bar').style.width = `${score}%`;
        
        const healthBar = document.getElementById('health-bar');
        if (score < 30) {
            healthBar.style.background = 'linear-gradient(90deg, #d32f2f, #f44336)';
        } else if (score < 70) {
            healthBar.style.background = 'linear-gradient(90deg, #f44336, #ff9800)';
        } else {
            healthBar.style.background = 'linear-gradient(90deg, #ff9800, #4caf50)';
        }
    }

    function updateTotalScore() {
        document.getElementById('total-score-value').textContent = totalScore;
    }

    function updateLevelDisplay() {
        document.getElementById('level').textContent = level;
        document.getElementById('max-turns').textContent = maxTurns;
    }

    function updateTurnCounter() {
        document.getElementById('turn-count').textContent = turn;
        const counter = document.querySelector('.stat-box:nth-child(4)');
        if (turn > maxTurns - 5) {
            counter.style.background = 'rgba(211,47,47,0.8)';
        } else {
            counter.style.background = 'rgba(255, 255, 255, 0.1)';
        }
    }

    function updateCooldowns() {
        bridgeCooldown = Math.max(0, 3 - (turn - lastBridgeTurn));
        clearCooldown = Math.max(0, 5 - (turn - lastClearTurn));
        
        document.getElementById('bridge-cooldown').textContent = 
            bridgeCooldown > 0 ? `${bridgeCooldown} turn${bridgeCooldown !== 1 ? 's' : ''}` : 'Ready!';
        document.getElementById('clear-cooldown').textContent = 
            clearCooldown > 0 ? `${clearCooldown} turn${clearCooldown !== 1 ? 's' : ''}` : 'Ready!';
        
        document.getElementById('bridge-btn').disabled = bridgeCooldown > 0;
        document.getElementById('clear-btn').disabled = clearCooldown > 0;
    }

    function showMessage(text, type = 'info') {
        const msg = document.getElementById('message');
        msg.textContent = text;
        msg.className = `message-box ${type}`;
        
        requestAnimationFrame(() => {
            msg.classList.add('show');
            setTimeout(() => {
                msg.classList.remove('show');
            }, 3000);
        });
    }

    // ================
    // HELPER FUNCTIONS
    // ================
    function getEmptyTiles() {
        const tiles = [];
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'empty') tiles.push({x, y});
            }
        }
        return tiles;
    }

    function getRandomSpecies() {
        const pool = [];
        SPECIES.forEach(species => {
            for (let i = 0; i < (4 - species.rarity); i++) {
                pool.push(species);
            }
        });
        return pool[Math.floor(Math.random() * pool.length)];
    }

    function getRandomThreat() {
        return THREATS[Math.floor(Math.random() * THREATS.length)];
    }

    function findSpecies(emoji) {
        return SPECIES.find(s => s.emoji === emoji) || SPECIES[0];
    }

    function resetGame() {
        level = 1;
        totalScore = 0;
        initGame();
        showMessage("Game reset! Connect plants to resources.", 'info');
    }

    // Start the game
    window.addEventListener('DOMContentLoaded', initGame);
</script>
</body>
</html>
