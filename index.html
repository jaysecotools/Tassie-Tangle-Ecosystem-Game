<!DOCTYPE html>
<html>
<head>
  <title>Tasmanian Tangle: Ultimate Ecosystem Game</title>
  <style>
    :root {
      --native-color: #81c784;
      --water-color: #4fc3f7;
      --weed-color: #ff8a65;
      --path-color: #aed581;
      --bridge-color: #bcaaa4;
    }
    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: url('https://images.unsplash.com/photo-1619566636858-adf3ef46400b?w=600') center/cover fixed;
      margin: 0;
      padding: 20px;
      text-align: center;
      color: #2e7d32;
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
      overflow-x: hidden;
    }
    #header {
      background: rgba(255,255,255,0.9);
      padding: 15px;
      border-radius: 10px;
      max-width: 800px;
      margin: 0 auto 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    h1 {
      margin: 0;
      font-size: 2.5em;
      color: #1b5e20;
    }
    #subtitle {
      font-style: italic;
      margin-top: 5px;
    }
    #game-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      max-width: 1000px;
      margin: 0 auto;
      flex-wrap: wrap;
    }
    #board-container {
      position: relative;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 70px);
      grid-gap: 5px;
      background: rgba(255,255,255,0.7);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.2);
      backdrop-filter: blur(3px);
    }
    .tile {
      width: 70px;
      height: 70px;
      background: rgba(255,255,255,0.8);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 30px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      position: relative;
      overflow: hidden;
    }
    .tile:hover {
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    .tile::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 60%);
      border-radius: 8px;
    }
    .tile.native { background: var(--native-color); }
    .tile.water { background: var(--water-color); }
    .tile.weed { background: var(--weed-color); }
    .tile.path { background: var(--path-color); }
    .tile.bridge { background: var(--bridge-color); }
    .tile.selected {
      animation: pulse 1.5s infinite;
      box-shadow: 0 0 0 4px #ffee58, 0 0 20px #ffeb3b;
    }
    .tile.connected {
      box-shadow: 0 0 0 3px #4caf50, 0 0 15px rgba(76, 175, 80, 0.5);
    }
    #sidebar {
      background: rgba(255,255,255,0.9);
      padding: 20px;
      border-radius: 15px;
      width: 250px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      text-align: left;
    }
    #resources {
      background: rgba(0,0,0,0.05);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    .resource {
      display: flex;
      align-items: center;
      margin: 8px 0;
    }
    .resource-icon {
      font-size: 24px;
      margin-right: 10px;
    }
    #species-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 15px;
    }
    .species-card {
      background: white;
      padding: 10px;
      margin: 8px 0;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: all 0.3s;
    }
    .species-card:hover {
      transform: translateX(5px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.1);
    }
    .species-name {
      font-weight: bold;
      margin-bottom: 5px;
      color: #1b5e20;
    }
    #abilities {
      background: rgba(0,0,0,0.05);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    .ability {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 8px 0;
    }
    #message {
      background: rgba(255,255,255,0.8);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      font-weight: bold;
      min-height: 20px;
      transition: all 0.3s;
    }
    #controls {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }
    button {
      background: linear-gradient(to bottom, #2e7d32, #1b5e20);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      flex: 1;
      margin: 0 5px;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.3);
    }
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    #score-display {
      font-size: 1.2em;
      font-weight: bold;
      margin: 10px 0;
    }
    #level-display {
      font-size: 1.1em;
      margin-bottom: 10px;
      color: #1b5e20;
    }
    #total-score {
      font-size: 1.1em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #1b5e20;
    }
    #turn-counter {
      position: absolute;
      top: -25px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.9em;
    }
    .cooldown {
      font-size: 0.8em;
      color: #666;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0px); }
    }
    .floating {
      animation: float 3s ease-in-out infinite;
    }
    .highlight {
      background-color: #fff9c4;
      padding: 2px 5px;
      border-radius: 3px;
    }
    .progress-container {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 5px;
      margin: 5px 0;
    }
    .progress-bar {
      height: 10px;
      border-radius: 5px;
      background-color: #4caf50;
      width: 0%;
      transition: width 0.3s;
    }
    .connection-line {
      position: absolute;
      background-color: #4caf50;
      z-index: 10;
      transform-origin: left center;
    }
    #tutorial {
      background: rgba(255,255,255,0.9);
      padding: 15px;
      border-radius: 10px;
      max-width: 800px;
      margin: 20px auto;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      text-align: left;
    }
    #tutorial h3 {
      margin-top: 0;
      color: #1b5e20;
    }
    #tutorial ol {
      padding-left: 20px;
    }
    #level-up-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
      font-size: 1.5em;
      text-align: center;
      display: none;
    }
    #level-up-content {
      background: rgba(255,255,255,0.9);
      padding: 30px;
      border-radius: 15px;
      color: #1b5e20;
      max-width: 500px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    #level-up-screen h2 {
      margin-top: 0;
      color: #1b5e20;
    }
    #level-up-screen button {
      margin-top: 20px;
      font-size: 1.2em;
      padding: 10px 20px;
    }
  </style>
</head>
<body>
  <div id="header">
    <h1>üåø Tasmanian Tangle</h1>
    <p id="subtitle">Restore Tasmania's fragile ecosystems!</p>
  </div>

  <div id="tutorial">
    <h3>How to Play:</h3>
    <ol>
      <li><strong>Select native plants</strong> by clicking on them (green tiles)</li>
      <li><strong>Connect them to resources</strong> they need (water üíß or sun ‚òÄÔ∏è) by clicking the resource</li>
      <li>Paths will automatically grow between them if there's a clear route</li>
      <li>Use <strong>tools</strong> to build bridges üåâ (over obstacles) or clear weeds üåæ</li>
      <li>Complete each level before time runs out to advance!</li>
    </ol>
  </div>

  <div id="game-container">
    <div id="board-container">
      <div id="turn-counter">Turn: <span id="turn-count">1</span>/<span id="max-turns">20</span></div>
      <div id="board"></div>
    </div>
    
    <div id="sidebar">
      <div id="level-display">üåø Level: <span id="level">1</span></div>
      <div id="total-score">üèÜ Total Score: <span id="total-score-value">0</span></div>
      <div id="score-display">üå± Ecosystem Health: <span id="score">0</span>%</div>
      <div class="progress-container">
        <div id="health-bar" class="progress-bar"></div>
      </div>
      
      <div id="resources">
        <div class="resource">
          <div class="resource-icon">üíß</div>
          <div>Water Sources: <span id="water-count">0</span></div>
        </div>
        <div class="resource">
          <div class="resource-icon">‚òÄÔ∏è</div>
          <div>Sun Patches: <span id="sun-count">0</span></div>
        </div>
      </div>
      
      <div id="abilities">
        <h3>Tools:</h3>
        <div class="ability">
          <button id="bridge-btn" onclick="useTool('bridge')">üåâ Build Bridge <span id="bridge-cooldown" class="cooldown"></span></button>
        </div>
        <div class="ability">
          <button id="clear-btn" onclick="useTool('clear')">üîÑ Clear Weeds <span id="clear-cooldown" class="cooldown"></span></button>
        </div>
      </div>
      
      <div id="message">Select a native plant, then connect it to resources!</div>
      
      <h3>Native Species:</h3>
      <div id="species-list"></div>
      
      <div id="controls">
        <button onclick="endTurn()">End Turn</button>
        <button onclick="resetGame()">Restart</button>
      </div>
    </div>
  </div>

  <div id="level-up-screen">
    <div id="level-up-content">
      <h2>Level Complete! üéâ</h2>
      <p>You restored the ecosystem to 100% health!</p>
      <p>Level <span id="completed-level">1</span> Score: <span id="level-score">0</span></p>
      <p>Total Score: <span id="new-total-score">0</span></p>
      <button onclick="startNextLevel()">Continue to Level <span id="next-level">2</span> ‚Üí</button>
    </div>
  </div>

  <script>
    // ================
    // GAME CONFIG
    // ================
    const BOARD_SIZE = 8;
    const BASE_TURNS = 20;
    const SPECIES = [
      { 
        emoji: 'üåø', 
        name: 'Tasmanian Blue Gum', 
        needs: ['water'], 
        desc: 'Iconic tree that koalas depend on',
        rarity: 1,
        points: 10
      },
      { 
        emoji: 'üå∏', 
        name: 'Leatherwood', 
        needs: ['water', 'sun'], 
        desc: 'Vital for native honey production',
        rarity: 2,
        points: 20
      },
      { 
        emoji: 'üå≤', 
        name: 'Huon Pine', 
        needs: ['water'], 
        desc: 'One of the oldest living tree species',
        rarity: 3,
        points: 15
      },
      { 
        emoji: 'üçÇ', 
        name: 'Waratah', 
        needs: ['sun'], 
        desc: 'Tasmania\'s floral emblem',
        rarity: 1,
        points: 10
      }
    ];

    // ================
    // GAME STATE
    // ================
    let board = [];
    let selectedTile = null;
    let score = 0;
    let turn = 1;
    let gameActive = true;
    let discoveredSpecies = [];
    let lastBridgeTurn = -3;
    let lastClearTurn = -5;
    let connections = [];
    let multiplier = 1;
    let level = 1;
    let totalScore = 0;
    let levelScore = 0;
    let maxTurns = BASE_TURNS;

    // ================
    // INITIALIZATION
    // ================
    function initGame() {
      const boardElement = document.getElementById('board');
      boardElement.innerHTML = '';
      board = [];
      selectedTile = null;
      score = 0;
      levelScore = 0;
      turn = 1;
      gameActive = true;
      discoveredSpecies = [];
      lastBridgeTurn = -3;
      lastClearTurn = -5;
      connections = [];
      multiplier = 1;
      
      maxTurns = Math.max(10, BASE_TURNS - Math.floor(level / 2));
      
      updateScore();
      updateTurnCounter();
      updateCooldowns();
      updateLevelDisplay();
      updateTotalScore();
      
      // Create empty board
      for (let y = 0; y < BOARD_SIZE; y++) {
        board[y] = [];
        for (let x = 0; x < BOARD_SIZE; x++) {
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.dataset.x = x;
          tile.dataset.y = y;
          tile.addEventListener('click', () => handleTileClick(x, y));
          boardElement.appendChild(tile);
          board[y][x] = { 
            type: 'empty', 
            element: tile,
            connected: false
          };
        }
      }

      // Place game elements
      placeInitialElements();
      renderSpeciesList();
      showMessage(`Level ${level}: Connect plants to resources!`, false);
      updateResourceCounts();
    }

    function placeInitialElements() {
      // Clear board first
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          board[y][x].type = 'empty';
          board[y][x].element.textContent = '';
          board[y][x].element.className = 'tile';
          board[y][x].connected = false;
        }
      }
      
      // Place 4 water sources
      placeRandom('water', 'üíß', 4);
      
      // Place 4 sun patches
      placeRandom('sun', '‚òÄÔ∏è', 4);
      
      // Place native plants - 2 of each species
      SPECIES.forEach(species => {
        placeRandom('native', species.emoji, 2);
      });
      
      // Place some weeds
      placeRandom('weed', 'üåæ', 5);
    }

    function placeRandom(type, emoji, count) {
      for (let i = 0; i < count; i++) {
        let placed = false;
        let attempts = 0;
        
        while (!placed && attempts < 50) {
          const x = Math.floor(Math.random() * BOARD_SIZE);
          const y = Math.floor(Math.random() * BOARD_SIZE);
          
          if (board[y][x].type === 'empty') {
            convertTile(x, y, type, emoji);
            placed = true;
          }
          attempts++;
        }
      }
    }

    function convertTile(x, y, type, emoji) {
      board[y][x].type = type;
      board[y][x].element.textContent = emoji;
      board[y][x].element.className = 'tile ' + type;
      
      // Add floating animation for water and sun
      if (type === 'water' || type === 'sun') {
        board[y][x].element.classList.add('floating');
      } else {
        board[y][x].element.classList.remove('floating');
      }
    }

    // ================
    // GAME LOGIC
    // ================
    function handleTileClick(x, y) {
      if (!gameActive) return;
      
      const tile = board[y][x];
      console.log(`Clicked tile at (${x}, ${y}) type: ${tile.type}`);
      
      // Select native plant
      if (tile.type === 'native') {
        if (selectedTile && selectedTile.x === x && selectedTile.y === y) {
          // Deselect if clicking same tile
          selectedTile.element.classList.remove('selected');
          selectedTile = null;
          showMessage("Plant deselected.", false);
          return;
        }
        
        // Deselect previous selection
        if (selectedTile) {
          selectedTile.element.classList.remove('selected');
        }
        
        // Select new tile
        selectedTile = { 
          x, y, 
          element: tile.element,
          species: findSpecies(tile.element.textContent)
        };
        tile.element.classList.add('selected');
        
        // Discover new species
        if (!discoveredSpecies.includes(selectedTile.species.name)) {
          discoveredSpecies.push(selectedTile.species.name);
          renderSpeciesList();
          showMessage(`Discovered: ${selectedTile.species.name}! ${selectedTile.species.desc}`, false);
        } else {
          showMessage(`Selected: ${selectedTile.species.name}. Needs: ${selectedTile.species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' and ')}.`, false);
        }
      } 
      // Connect to resource
      else if (selectedTile && (tile.type === 'water' || tile.type === 'sun')) {
        console.log(`Attempting to connect plant at (${selectedTile.x}, ${selectedTile.y}) to ${tile.type} at (${x}, ${y})`);
        
        if (selectedTile.species.needs.includes(tile.type)) {
          if (connectTiles(selectedTile.x, selectedTile.y, x, y)) {
            selectedTile.element.classList.remove('selected');
            selectedTile = null;
          }
        } else {
          showMessage(`This plant doesn't need ${tile.type}! It needs ${selectedTile.species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' and ')}.`, true);
        }
      }
      // Use tools on empty tiles
      else if (selectedTile && tile.type === 'empty') {
        showMessage(`Select a resource (üíß or ‚òÄÔ∏è) to connect to this plant.`, false);
      }
      // Clicked something else with plant selected
      else if (selectedTile) {
        showMessage(`Select a ${selectedTile.species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' or ')} resource for this plant.`, false);
      }
    }

    function connectTiles(x1, y1, x2, y2) {
      console.log(`connectTiles called: (${x1},${y1}) to (${x2},${y2})`);
      
      // Check if connection is possible
      const path = findPath(x1, y1, x2, y2);
      
      if (!path || path.length === 0) {
        showMessage("Cannot connect these tiles! No clear path.", true);
        return false;
      }

      // Check if already connected
      const connectionKey = `${x1},${y1}-${x2},${y2}`;
      const reverseKey = `${x2},${y2}-${x1},${y1}`;
      if (connections.includes(connectionKey) || connections.includes(reverseKey)) {
        showMessage("These are already connected!", true);
        return false;
      }

      // Add to connections
      connections.push(connectionKey);

      // Create path with animation
      path.forEach(({x, y}, i) => {
        setTimeout(() => {
          // Only convert empty tiles to paths
          if (board[y][x].type === 'empty') {
            convertTile(x, y, 'path', 'üå±');
          }
        }, i * 100);
      });

      // Mark both ends as connected
      setTimeout(() => {
        board[y1][x1].connected = true;
        board[y1][x1].element.classList.add('connected');
        board[y2][x2].connected = true;
        board[y2][x2].element.classList.add('connected');
        
        // Check if plant has all needs met
        checkPlantNeeds(x1, y1);
        
        showMessage("üå± Connection successful!", false);
        checkGameState();
      }, path.length * 100 + 200);

      return true;
    }

    function findPath(x1, y1, x2, y2) {
      console.log(`Finding path from (${x1},${y1}) to (${x2},${y2})`);
      
      // Simple pathfinding: try straight lines first, then L-shapes
      const paths = [];
      
      // Try horizontal then vertical (L-shape)
      if (canMoveStraight(x1, y1, x2, y1) && canMoveStraight(x2, y1, x2, y2)) {
        const path = [];
        // Horizontal segment
        const xStep = x1 < x2 ? 1 : -1;
        for (let x = x1 + xStep; x !== x2; x += xStep) {
          if (x < 0 || x >= BOARD_SIZE) break;
          path.push({x, y: y1});
        }
        // Vertical segment
        const yStep = y1 < y2 ? 1 : -1;
        for (let y = y1; y !== y2; y += yStep) {
          if (y < 0 || y >= BOARD_SIZE) break;
          path.push({x: x2, y});
        }
        paths.push(path);
      }
      
      // Try vertical then horizontal (L-shape)
      if (canMoveStraight(x1, y1, x1, y2) && canMoveStraight(x1, y2, x2, y2)) {
        const path = [];
        // Vertical segment
        const yStep = y1 < y2 ? 1 : -1;
        for (let y = y1 + yStep; y !== y2; y += yStep) {
          if (y < 0 || y >= BOARD_SIZE) break;
          path.push({x: x1, y});
        }
        // Horizontal segment
        const xStep = x1 < x2 ? 1 : -1;
        for (let x = x1; x !== x2; x += xStep) {
          if (x < 0 || x >= BOARD_SIZE) break;
          path.push({x, y: y2});
        }
        paths.push(path);
      }
      
      // Find the shortest valid path
      let shortestPath = null;
      for (const path of paths) {
        if (path.length > 0 && isPathClear(path)) {
          if (!shortestPath || path.length < shortestPath.length) {
            shortestPath = path;
          }
        }
      }
      
      console.log(`Found path:`, shortestPath);
      return shortestPath || [];
    }

    function canMoveStraight(x1, y1, x2, y2) {
      // Check if we can move in a straight line
      if (x1 === x2) {
        // Vertical movement
        const step = y1 < y2 ? 1 : -1;
        for (let y = y1 + step; y !== y2; y += step) {
          if (y < 0 || y >= BOARD_SIZE) return false;
          if (board[y][x1].type !== 'empty' && 
              board[y][x1].type !== 'path' && 
              !(x1 === x2 && y === y2)) {
            return false;
          }
        }
        return true;
      } else if (y1 === y2) {
        // Horizontal movement
        const step = x1 < x2 ? 1 : -1;
        for (let x = x1 + step; x !== x2; x += step) {
          if (x < 0 || x >= BOARD_SIZE) return false;
          if (board[y1][x].type !== 'empty' && 
              board[y1][x].type !== 'path' && 
              !(x === x2 && y1 === y2)) {
            return false;
          }
        }
        return true;
      }
      return false;
    }

    function isPathClear(path) {
      for (const {x, y} of path) {
        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) {
          return false;
        }
        if (board[y][x].type !== 'empty' && board[y][x].type !== 'path') {
          return false;
        }
      }
      return true;
    }

    function checkPlantNeeds(x, y) {
      if (board[y][x].type !== 'native') return;
      
      const species = findSpecies(board[y][x].element.textContent);
      const needs = species.needs;
      let needsMet = 0;
      
      // Check all water and sun tiles
      for (let ty = 0; ty < BOARD_SIZE; ty++) {
        for (let tx = 0; tx < BOARD_SIZE; tx++) {
          if (board[ty][tx].type === 'water' && needs.includes('water')) {
            if (areConnected(x, y, tx, ty)) {
              needsMet++;
              break; // Found one water connection
            }
          }
        }
      }
      
      for (let ty = 0; ty < BOARD_SIZE; ty++) {
        for (let tx = 0; tx < BOARD_SIZE; tx++) {
          if (board[ty][tx].type === 'sun' && needs.includes('sun')) {
            if (areConnected(x, y, tx, ty)) {
              needsMet++;
              break; // Found one sun connection
            }
          }
        }
      }
      
      console.log(`Plant at (${x},${y}) needs ${needs.length}, has ${needsMet} met`);
      
      if (needsMet >= needs.length) {
        // Plant is fully connected
        multiplier += 0.2;
        levelScore += species.points * multiplier;
        totalScore += species.points * multiplier;
        updateTotalScore();
        showMessage(`Great job! ${species.name} is thriving! Multiplier: x${multiplier.toFixed(1)}`, false);
      }
    }

    function areConnected(x1, y1, x2, y2) {
      // Simple connection check - are they in the connections list?
      const connectionKey = `${x1},${y1}-${x2},${y2}`;
      const reverseKey = `${x2},${y2}-${x1},${y1}`;
      return connections.includes(connectionKey) || connections.includes(reverseKey);
    }

    function useTool(toolType) {
      if (!selectedTile) {
        showMessage("Select a tile first!", true);
        return;
      }

      const {x, y} = selectedTile;
      
      switch(toolType) {
        case 'bridge':
          if (turn - lastBridgeTurn < 3) {
            showMessage(`Bridge on cooldown! Wait ${3 - (turn - lastBridgeTurn)} more turns.`, true);
            return;
          }
          if (board[y][x].type !== 'empty') {
            showMessage("Can only build bridges on empty tiles!", true);
            return;
          }
          convertTile(x, y, 'bridge', 'üåâ');
          lastBridgeTurn = turn;
          updateCooldowns();
          showMessage("Built a bridge! Now connect plants through it.", false);
          break;
          
        case 'clear':
          if (turn - lastClearTurn < 5) {
            showMessage(`Weed clearing on cooldown! Wait ${5 - (turn - lastClearTurn)} more turns.`, true);
            return;
          }
          if (board[y][x].type !== 'weed') {
            showMessage("Can only clear weed tiles!", true);
            return;
          }
          convertTile(x, y, 'empty', '');
          lastClearTurn = turn;
          updateCooldowns();
          showMessage("Cleared weeds! Native plants can grow here now.", false);
          break;
      }
      
      selectedTile.element.classList.remove('selected');
      selectedTile = null;
    }

    function endTurn() {
      if (!gameActive) return;
      
      turn++;
      updateTurnCounter();
      updateCooldowns();
      
      // Weeds spread
      spreadWeeds(0.3);
      
      // Random events
      if (turn > 3 && Math.random() < 0.3) {
        triggerRandomEvent();
      }
      
      // Check win/lose
      checkGameState();
      
      // Respawn resources periodically
      if (turn % 4 === 0) {
        respawnResources();
      }
      
      showMessage(`Turn ${turn} started. Connect more plants!`, false);
    }

    function spreadWeeds(spreadRate) {
      const newWeeds = [];
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'weed' && Math.random() < spreadRate) {
            const directions = [
              {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
            ];
            
            for (const dir of directions) {
              const nx = x + dir.dx;
              const ny = y + dir.dy;
              if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                  board[ny][nx].type === 'empty') {
                newWeeds.push({x: nx, y: ny});
                break;
              }
            }
          }
        }
      }
      
      if (newWeeds.length > 0) {
        newWeeds.forEach(({x, y}) => {
          convertTile(x, y, 'weed', 'üåæ');
        });
      }
    }

    function respawnResources() {
      const emptyTiles = getEmptyTiles();
      if (emptyTiles.length === 0) return;
      
      const waterCount = countResources('water');
      const sunCount = countResources('sun');
      const respawnType = waterCount <= sunCount ? 'water' : 'sun';
      
      const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
      convertTile(x, y, respawnType, respawnType === 'water' ? 'üíß' : '‚òÄÔ∏è');
      
      updateResourceCounts();
    }

    function triggerRandomEvent() {
      const events = [
        { 
          name: 'Rainfall', 
          effect: () => {
            const emptyTiles = getEmptyTiles();
            if (emptyTiles.length > 0) {
              const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
              convertTile(x, y, 'water', 'üíß');
              showMessage("üåßÔ∏è Rainfall created a new water source!", false);
              updateResourceCounts();
            }
          }
        },
        {
          name: 'Sunny Break',
          effect: () => {
            const emptyTiles = getEmptyTiles();
            if (emptyTiles.length > 0) {
              const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
              convertTile(x, y, 'sun', '‚òÄÔ∏è');
              showMessage("‚òÄÔ∏è Sunshine created a new sunny patch!", false);
              updateResourceCounts();
            }
          }
        }
      ];
      
      const event = events[Math.floor(Math.random() * events.length)];
      event.effect();
    }

    function checkGameState() {
      // Check connected plants
      let connectedPlants = 0;
      let totalPlants = 0;
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'native') {
            totalPlants++;
            const species = findSpecies(board[y][x].element.textContent);
            let needsMet = 0;
            
            // Check water needs
            if (species.needs.includes('water')) {
              for (let ty = 0; ty < BOARD_SIZE; ty++) {
                for (let tx = 0; tx < BOARD_SIZE; tx++) {
                  if (board[ty][tx].type === 'water' && areConnected(x, y, tx, ty)) {
                    needsMet++;
                    break;
                  }
                }
              }
            }
            
            // Check sun needs
            if (species.needs.includes('sun')) {
              for (let ty = 0; ty < BOARD_SIZE; ty++) {
                for (let tx = 0; tx < BOARD_SIZE; tx++) {
                  if (board[ty][tx].type === 'sun' && areConnected(x, y, tx, ty)) {
                    needsMet++;
                    break;
                  }
                }
              }
            }
            
            if (needsMet >= species.needs.length) {
              connectedPlants++;
            }
          }
        }
      }
      
      // Update score
      const newScore = totalPlants > 0 ? Math.floor((connectedPlants / totalPlants) * 100) : 0;
      if (newScore !== score) {
        score = newScore;
        updateScore();
      }
      
      console.log(`Game state: ${connectedPlants}/${totalPlants} plants connected, score: ${score}%`);
      
      // Win/lose conditions
      if (score === 100) {
        gameActive = false;
        levelComplete();
      } else if (turn >= maxTurns) {
        gameActive = false;
        showMessage(`üíÄ Time's up! You restored ${score}% of the ecosystem. Total Score: ${totalScore}`, true);
      }
    }

    function levelComplete() {
      // Calculate bonus points for remaining turns
      const bonusPoints = (maxTurns - turn) * 5 * level;
      levelScore += bonusPoints;
      totalScore += bonusPoints;
      
      // Show level complete screen
      document.getElementById('completed-level').textContent = level;
      document.getElementById('level-score').textContent = levelScore;
      document.getElementById('new-total-score').textContent = totalScore;
      document.getElementById('next-level').textContent = level + 1;
      document.getElementById('level-up-screen').style.display = 'flex';
    }

    function startNextLevel() {
      level++;
      document.getElementById('level-up-screen').style.display = 'none';
      initGame();
    }

    // ================
    // UI UPDATES
    // ================
    function renderSpeciesList() {
      const list = document.getElementById('species-list');
      list.innerHTML = '';
      
      SPECIES.forEach(species => {
        const card = document.createElement('div');
        card.className = 'species-card';
        card.innerHTML = `
          <div class="species-name">${species.emoji} ${species.name}</div>
          <div style="font-size:0.9em; color:#666;">
            Needs: ${species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' + ')}
          </div>
          ${discoveredSpecies.includes(species.name) ? 
            `<div style="font-size:0.8em; margin-top:5px;">${species.desc}</div>` : 
            '<div style="font-size:0.8em; color:#999;">Not discovered yet</div>'}
        `;
        list.appendChild(card);
      });
    }

    function updateResourceCounts() {
      document.getElementById('water-count').textContent = countResources('water');
      document.getElementById('sun-count').textContent = countResources('sun');
    }

    function countResources(type) {
      let count = 0;
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === type) count++;
        }
      }
      return count;
    }

    function updateScore() {
      document.getElementById('score').textContent = score;
      document.getElementById('health-bar').style.width = `${score}%`;
      
      const scoreDisplay = document.getElementById('score-display');
      scoreDisplay.style.color = 
        score < 30 ? '#d32f2f' : score < 70 ? '#ff8f00' : '#2e7d32';
    }

    function updateTotalScore() {
      document.getElementById('total-score-value').textContent = totalScore;
    }

    function updateLevelDisplay() {
      document.getElementById('level').textContent = level;
      document.getElementById('max-turns').textContent = maxTurns;
    }

    function updateTurnCounter() {
      document.getElementById('turn-count').textContent = turn;
      const counter = document.getElementById('turn-counter');
      counter.style.backgroundColor = 
        turn > maxTurns - 5 ? 'rgba(211,47,47,0.8)' : 'rgba(0,0,0,0.7)';
    }

    function updateCooldowns() {
      const bridgeCooldown = Math.max(0, 3 - (turn - lastBridgeTurn));
      const clearCooldown = Math.max(0, 5 - (turn - lastClearTurn));
      
      document.getElementById('bridge-cooldown').textContent = 
        bridgeCooldown > 0 ? `${bridgeCooldown} turn${bridgeCooldown !== 1 ? 's' : ''}` : '';
      document.getElementById('clear-cooldown').textContent = 
        clearCooldown > 0 ? `${clearCooldown} turn${clearCooldown !== 1 ? 's' : ''}` : '';
      
      document.getElementById('bridge-btn').disabled = bridgeCooldown > 0;
      document.getElementById('clear-btn').disabled = clearCooldown > 0;
    }

    function showMessage(text, isWarning) {
      const msg = document.getElementById('message');
      msg.innerHTML = text;
      msg.style.background = isWarning ? 'rgba(255,205,210,0.8)' : 'rgba(200,230,201,0.8)';
      msg.style.color = isWarning ? '#d32f2f' : '#2e7d32';
    }

    // ================
    // HELPER FUNCTIONS
    // ================
    function getEmptyTiles() {
      const tiles = [];
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'empty') tiles.push({x, y});
        }
      }
      return tiles;
    }

    function findSpecies(emoji) {
      return SPECIES.find(s => s.emoji === emoji) || SPECIES[0];
    }

    function resetGame() {
      level = 1;
      totalScore = 0;
      initGame();
      showMessage("Game reset! Connect plants to resources.", false);
    }

    // Start the game
    initGame();
  </script>
</body>
</html>
