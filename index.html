<!DOCTYPE html>
<html>
<head>
  <title>Tasmanian Tangle: Ultimate Edition</title>
  <style>
    :root {
      --native-color: #81c784;
      --water-color: #4fc3f7;
      --weed-color: #ff8a65;
      --path-color: #aed581;
    }
    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: url('https://images.unsplash.com/photo-1619566636858-adf3ef46400b?w=600') center/cover fixed;
      margin: 0;
      padding: 20px;
      text-align: center;
      color: #2e7d32;
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
      overflow-x: hidden;
    }
    #header {
      background: rgba(255,255,255,0.9);
      padding: 15px;
      border-radius: 10px;
      max-width: 800px;
      margin: 0 auto 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    h1 {
      margin: 0;
      font-size: 2.5em;
      color: #1b5e20;
    }
    #subtitle {
      font-style: italic;
      margin-top: 5px;
    }
    #game-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      max-width: 1000px;
      margin: 0 auto;
      flex-wrap: wrap;
    }
    #board-container {
      position: relative;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 70px);
      grid-gap: 5px;
      background: rgba(255,255,255,0.7);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.2);
      backdrop-filter: blur(3px);
    }
    .tile {
      width: 70px;
      height: 70px;
      background: rgba(255,255,255,0.8);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 30px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      position: relative;
      overflow: hidden;
    }
    .tile:hover {
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    .tile::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 60%);
      border-radius: 8px;
    }
    .tile.native { background: var(--native-color); }
    .tile.water { background: var(--water-color); }
    .tile.weed { background: var(--weed-color); }
    .tile.path { background: var(--path-color); }
    .tile.selected {
      animation: pulse 1.5s infinite;
      box-shadow: 0 0 0 4px #ffee58, 0 0 20px #ffeb3b;
    }
    #sidebar {
      background: rgba(255,255,255,0.9);
      padding: 20px;
      border-radius: 15px;
      width: 250px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      text-align: left;
    }
    #resources {
      background: rgba(0,0,0,0.05);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    .resource {
      display: flex;
      align-items: center;
      margin: 8px 0;
    }
    .resource-icon {
      font-size: 24px;
      margin-right: 10px;
    }
    #species-list {
      max-height: 300px;
      overflow-y: auto;
    }
    .species-card {
      background: white;
      padding: 10px;
      margin: 8px 0;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: all 0.3s;
    }
    .species-card:hover {
      transform: translateX(5px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.1);
    }
    .species-name {
      font-weight: bold;
      margin-bottom: 5px;
      color: #1b5e20;
    }
    #message {
      background: rgba(255,255,255,0.8);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      font-weight: bold;
      min-height: 20px;
      transition: all 0.3s;
    }
    #controls {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }
    button {
      background: linear-gradient(to bottom, #2e7d32, #1b5e20);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      flex: 1;
      margin: 0 5px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.3);
    }
    button:active {
      transform: translateY(0);
    }
    #score-display {
      font-size: 1.2em;
      font-weight: bold;
      margin: 10px 0;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0px); }
    }
    .floating {
      animation: float 3s ease-in-out infinite;
    }
    #turn-counter {
      position: absolute;
      top: -25px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.9em;
    }
    .highlight {
      background-color: #fff9c4;
      padding: 2px 5px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="header">
    <h1>üåø Tasmanian Tangle</h1>
    <p id="subtitle">Restore Tasmania's fragile ecosystems!</p>
  </div>

  <div id="game-container">
    <div id="board-container">
      <div id="turn-counter">Turn: <span id="turn-count">1</span></div>
      <div id="board"></div>
    </div>
    
    <div id="sidebar">
      <div id="score-display">üèÜ Ecosystem Health: <span id="score">0</span>%</div>
      
      <div id="resources">
        <div class="resource">
          <div class="resource-icon">üíß</div>
          <div>Water Sources: <span id="water-count">0</span></div>
        </div>
        <div class="resource">
          <div class="resource-icon">‚òÄÔ∏è</div>
          <div>Sun Patches: <span id="sun-count">0</span></div>
        </div>
      </div>
      
      <div id="message">Select a native plant, then connect it to resources!</div>
      
      <h3>Native Species:</h3>
      <div id="species-list"></div>
      
      <div id="controls">
        <button onclick="endTurn()">End Turn</button>
        <button onclick="resetGame()">Restart</button>
      </div>
    </div>
  </div>

  <script>
    // ================
    // GAME CONFIG
    // ================
    const BOARD_SIZE = 8;
    const SPECIES = [
      { 
        emoji: 'üåø', 
        name: 'Tasmanian Blue Gum', 
        needs: ['water'], 
        desc: 'Iconic tree that koalas depend on',
        rarity: 1
      },
      { 
        emoji: 'üå∏', 
        name: 'Leatherwood', 
        needs: ['water', 'sun'], 
        desc: 'Vital for native honey production',
        rarity: 2
      },
      { 
        emoji: 'üå≤', 
        name: 'Huon Pine', 
        needs: ['water'], 
        desc: 'One of the oldest living tree species',
        rarity: 3
      },
      { 
        emoji: 'üçÇ', 
        name: 'Waratah', 
        needs: ['sun'], 
        desc: 'Tasmania\'s floral emblem',
        rarity: 1
      }
    ];
    
    const THREATS = [
      { emoji: 'üî•', name: 'Bushfire', effect: 'Destroys paths and plants' },
      { emoji: 'ü¶ä', name: 'Fox', effect: 'Eats native animals' },
      { emoji: 'üåæ', name: 'Gorse', effect: 'Invasive weed that spreads fast' }
    ];

    // ================
    // GAME STATE
    // ================
    let board = [];
    let selectedTile = null;
    let score = 0;
    let turn = 1;
    let gameActive = true;
    let discoveredSpecies = [];

    // ================
    // INITIALIZATION
    // ================
    function initGame() {
      const boardElement = document.getElementById('board');
      boardElement.innerHTML = '';
      board = [];
      selectedTile = null;
      score = 0;
      turn = 1;
      gameActive = true;
      discoveredSpecies = [];
      updateScore();
      updateTurnCounter();
      
      // Create tiles
      for (let y = 0; y < BOARD_SIZE; y++) {
        board[y] = [];
        for (let x = 0; x < BOARD_SIZE; x++) {
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.dataset.x = x;
          tile.dataset.y = y;
          tile.addEventListener('click', () => handleTileClick(x, y));
          boardElement.appendChild(tile);
          board[y][x] = { 
            type: 'empty', 
            element: tile,
            revealed: false
          };
        }
      }

      // Place initial elements
      placeRandom('water', 'üíß', 4);
      placeRandom('sun', '‚òÄÔ∏è', 4);
      placeRandom('native', getRandomSpecies().emoji, 5);
      placeRandom('weed', getRandomThreat().emoji, 3);
      
      updateResourceCounts();
      renderSpeciesList();
      showMessage("Welcome! Connect native plants to resources.", false);
    }

    function placeRandom(type, emoji, count) {
      for (let i = 0; i < count; i++) {
        let x, y;
        do {
          x = Math.floor(Math.random() * BOARD_SIZE);
          y = Math.floor(Math.random() * BOARD_SIZE);
        } while (board[y][x].type !== 'empty');
        
        board[y][x].type = type;
        board[y][x].element.textContent = emoji;
        board[y][x].element.classList.add(type);
        
        // Special effects
        if (type === 'water') board[y][x].element.classList.add('floating');
        if (type === 'sun') board[y][x].element.style.animationDelay = `${Math.random() * 2}s`;
      }
    }

    // ================
    // GAME LOGIC
    // ================
    function handleTileClick(x, y) {
      if (!gameActive) return;
      
      const tile = board[y][x];
      
      // Select native plant
      if (tile.type === 'native') {
        if (selectedTile) selectedTile.element.classList.remove('selected');
        selectedTile = { 
          x, y, 
          element: tile.element,
          species: findSpecies(tile.element.textContent)
        };
        tile.element.classList.add('selected');
        
        // Discover new species
        if (!discoveredSpecies.includes(selectedTile.species.name)) {
          discoveredSpecies.push(selectedTile.species.name);
          renderSpeciesList();
          showMessage(`Discovered: ${selectedTile.species.name}! ${selectedTile.species.desc}`, false);
        } else {
          showMessage(`Selected: ${selectedTile.species.name}. Connect to ${selectedTile.species.needs.join(' and ')}.`, false);
        }
      } 
      // Connect to resource
      else if (selectedTile && (tile.type === 'water' || tile.type === 'sun')) {
        if (selectedTile.species.needs.includes(tile.type)) {
          if (connectTiles(selectedTile.x, selectedTile.y, x, y)) {
            selectedTile.element.classList.remove('selected');
            selectedTile = null;
          }
        } else {
          showMessage(`This plant doesn't need ${tile.type}!`, true);
        }
      }
    }

    function connectTiles(x1, y1, x2, y2) {
      // Only allow straight lines
      if (x1 !== x2 && y1 !== y2) {
        showMessage("‚ö†Ô∏è Connect in straight lines only!", true);
        return false;
      }

      // Check path
      const path = [];
      if (x1 === x2) { // Vertical line
        const start = Math.min(y1, y2);
        const end = Math.max(y1, y2);
        for (let y = start + 1; y < end; y++) {
          if (board[y][x1].type === 'weed') {
            showMessage("üö´ Path blocked by weeds!", true);
            return false;
          }
          if (board[y][x1].type !== 'empty' && board[y][x1].type !== 'path') {
            showMessage("üö´ Path blocked!", true);
            return false;
          }
          path.push({x: x1, y});
        }
      } else { // Horizontal line
        const start = Math.min(x1, x2);
        const end = Math.max(x1, x2);
        for (let x = start + 1; x < end; x++) {
          if (board[y1][x].type === 'weed') {
            showMessage("üö´ Path blocked by weeds!", true);
            return false;
          }
          if (board[y1][x].type !== 'empty' && board[y1][x].type !== 'path') {
            showMessage("üö´ Path blocked!", true);
            return false;
          }
          path.push({x, y: y1});
        }
      }

      // Draw path with animation
      path.forEach(({x, y}, i) => {
        setTimeout(() => {
          board[y][x].type = 'path';
          board[y][x].element.textContent = 'üå±';
          board[y][x].element.classList.add('path');
          board[y][x].element.classList.add('floating');
          board[y][x].element.style.animationDelay = `${i * 0.1}s`;
        }, i * 100);
      });

      showMessage("üå± Connection growing...", false);
      return true;
    }

    function endTurn() {
      if (!gameActive) return;
      
      turn++;
      updateTurnCounter();
      
      // Weeds spread
      spreadWeeds();
      
      // Random events
      if (Math.random() < 0.3) triggerRandomEvent();
      
      // Check win/lose
      checkGameState();
    }

    function spreadWeeds() {
      const newWeeds = [];
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'weed' && Math.random() < 0.4) {
            const directions = [
              {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
            ].sort(() => Math.random() - 0.5);
            
            for (const dir of directions) {
              const nx = x + dir.dx;
              const ny = y + dir.dy;
              if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                  board[ny][nx].type === 'empty') {
                newWeeds.push({x: nx, y: ny});
                break;
              }
            }
          }
        }
      }
      
      if (newWeeds.length > 0) {
        showMessage(`‚ö†Ô∏è Weeds spread to ${newWeeds.length} new areas!`, true);
        newWeeds.forEach(({x, y}) => {
          board[y][x].type = 'weed';
          board[y][x].element.textContent = getRandomThreat().emoji;
          board[y][x].element.classList.add('weed');
        });
      }
    }

    function triggerRandomEvent() {
      const events = [
        { 
          name: 'Rainfall', 
          effect: () => {
            const emptyTiles = [];
            for (let y = 0; y < BOARD_SIZE; y++) {
              for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'empty') emptyTiles.push({x, y});
              }
            }
            if (emptyTiles.length > 0) {
              const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
              board[y][x].type = 'water';
              board[y][x].element.textContent = 'üíß';
              board[y][x].element.classList.add('water', 'floating');
              showMessage("üåßÔ∏è Rainfall created a new water source!", false);
              updateResourceCounts();
            }
          },
          chance: 0.6
        },
        {
          name: 'Drought',
          effect: () => {
            const waterTiles = [];
            for (let y = 0; y < BOARD_SIZE; y++) {
              for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'water') waterTiles.push({x, y});
              }
            }
            if (waterTiles.length > 1) {
              const {x, y} = waterTiles[Math.floor(Math.random() * waterTiles.length)];
              board[y][x].type = 'empty';
              board[y][x].element.textContent = '';
              board[y][x].className = 'tile';
              showMessage("‚òÄÔ∏è Drought dried up a water source!", true);
              updateResourceCounts();
            }
          },
          chance: 0.4
        }
      ];
      
      const event = events.find(e => Math.random() < e.chance) || events[0];
      event.effect();
    }

    function checkGameState() {
      // Check connected plants
      let connectedPlants = 0;
      let totalPlants = 0;
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'native') {
            totalPlants++;
            const species = findSpecies(board[y][x].element.textContent);
            let needsMet = 0;
            
            for (let ty = 0; ty < BOARD_SIZE; ty++) {
              for (let tx = 0; tx < BOARD_SIZE; tx++) {
                if (board[ty][tx].type === 'water' && species.needs.includes('water')) {
                  if (isConnected(x, y, tx, ty)) needsMet++;
                }
                if (board[ty][tx].type === 'sun' && species.needs.includes('sun')) {
                  if (isConnected(x, y, tx, ty)) needsMet++;
                }
              }
            }
            
            if (needsMet >= species.needs.length) connectedPlants++;
          }
        }
      }
      
      // Update score
      score = Math.floor((connectedPlants / totalPlants) * 100);
      updateScore();
      
      // Win/lose conditions
      if (score === 100) {
        gameActive = false;
        showMessage("üéâ You restored the ecosystem! All plants are thriving!", false);
      } else if (turn >= 15) {
        gameActive = false;
        showMessage("üíÄ The ecosystem collapsed... Try again?", true);
      }
    }

    function isConnected(x1, y1, x2, y2) {
      if (x1 === x2 && y1 === y2) return true;
      
      const visited = new Set();
      const queue = [{x: x1, y: y1}];
      visited.add(`${x1},${y1}`);
      
      while (queue.length > 0) {
        const {x, y} = queue.shift();
        const directions = [{dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}];
        
        for (const dir of directions) {
          const nx = x + dir.dx;
          const ny = y + dir.dy;
          const key = `${nx},${ny}`;
          
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && !visited.has(key)) {
            if (nx === x2 && ny === y2) return true;
            
            if (board[ny][nx].type === 'path' || board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
              visited.add(key);
              queue.push({x: nx, y: ny});
            }
          }
        }
      }
      
      return false;
    }

    // ================
    // UI UPDATES
    // ================
    function renderSpeciesList() {
      const list = document.getElementById('species-list');
      list.innerHTML = '';
      
      SPECIES.forEach(species => {
        const card = document.createElement('div');
        card.className = 'species-card';
        card.innerHTML = `
          <div class="species-name">${species.emoji} ${species.name}</div>
          <div style="font-size:0.9em; color:#666;">
            Needs: ${species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' + ')}
          </div>
          ${discoveredSpecies.includes(species.name) ? 
            `<div style="font-size:0.8em; margin-top:5px;">${species.desc}</div>` : 
            '<div style="font-size:0.8em; color:#999;">Not discovered yet</div>'}
        `;
        list.appendChild(card);
      });
    }

    function updateResourceCounts() {
      let water = 0;
      let sun = 0;
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'water') water++;
          if (board[y][x].type === 'sun') sun++;
        }
      }
      
      document.getElementById('water-count').textContent = water;
      document.getElementById('sun-count').textContent = sun;
    }

    function updateScore() {
      document.getElementById('score').textContent = score;
      document.getElementById('score-display').style.color = 
        score < 30 ? '#d32f2f' : score < 70 ? '#ff8f00' : '#2e7d32';
    }

    function updateTurnCounter() {
      document.getElementById('turn-count').textContent = turn;
      document.getElementById('turn-counter').style.backgroundColor = 
        turn > 10 ? 'rgba(211,47,47,0.8)' : 'rgba(0,0,0,0.7)';
    }

    function showMessage(text, isWarning) {
      const msg = document.getElementById('message');
      msg.innerHTML = text;
      msg.style.background = isWarning ? 'rgba(255,205,210,0.8)' : 'rgba(200,230,201,0.8)';
      msg.style.color = isWarning ? '#d32f2f' : '#2e7d32';
    }

    // ================
    // HELPER FUNCTIONS
    // ================
    function getRandomSpecies() {
      // Weighted random based on rarity
      const pool = [];
      SPECIES.forEach(species => {
        for (let i = 0; i < (4 - species.rarity); i++) {
          pool.push(species);
        }
      });
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function getRandomThreat() {
      return THREATS[Math.floor(Math.random() * THREATS.length)];
    }

    function findSpecies(emoji) {
      return SPECIES.find(s => s.emoji === emoji) || SPECIES[0];
    }

    function resetGame() {
      initGame();
    }

    // Start the game
    initGame();
  </script>
</body>
</html>
