<!DOCTYPE html>
<html>
<head>
  <title>Tasmanian Tangle: Ultimate Ecosystem Game</title>
  <style>
    :root {
      --native-color: #81c784;
      --water-color: #4fc3f7;
      --weed-color: #ff8a65;
      --path-color: #aed581;
      --bridge-color: #bcaaa4;
    }
    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: url('https://images.unsplash.com/photo-1619566636858-adf3ef46400b?w=600') center/cover fixed;
      margin: 0;
      padding: 20px;
      text-align: center;
      color: #2e7d32;
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
      overflow-x: hidden;
    }
    #header {
      background: rgba(255,255,255,0.9);
      padding: 15px;
      border-radius: 10px;
      max-width: 800px;
      margin: 0 auto 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    h1 {
      margin: 0;
      font-size: 2.5em;
      color: #1b5e20;
    }
    #subtitle {
      font-style: italic;
      margin-top: 5px;
    }
    #game-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      max-width: 1000px;
      margin: 0 auto;
      flex-wrap: wrap;
    }
    #board-container {
      position: relative;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 70px);
      grid-gap: 5px;
      background: rgba(255,255,255,0.7);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.2);
      backdrop-filter: blur(3px);
    }
    .tile {
      width: 70px;
      height: 70px;
      background: rgba(255,255,255,0.8);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 30px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      position: relative;
      overflow: hidden;
    }
    .tile:hover {
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    .tile::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 60%);
      border-radius: 8px;
    }
    .tile.native { background: var(--native-color); }
    .tile.water { background: var(--water-color); }
    .tile.weed { background: var(--weed-color); }
    .tile.path { background: var(--path-color); }
    .tile.bridge { background: var(--bridge-color); }
    .tile.selected {
      animation: pulse 1.5s infinite;
      box-shadow: 0 0 0 4px #ffee58, 0 0 20px #ffeb3b;
    }
    #sidebar {
      background: rgba(255,255,255,0.9);
      padding: 20px;
      border-radius: 15px;
      width: 250px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      text-align: left;
    }
    #resources {
      background: rgba(0,0,0,0.05);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    .resource {
      display: flex;
      align-items: center;
      margin: 8px 0;
    }
    .resource-icon {
      font-size: 24px;
      margin-right: 10px;
    }
    #species-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 15px;
    }
    .species-card {
      background: white;
      padding: 10px;
      margin: 8px 0;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: all 0.3s;
    }
    .species-card:hover {
      transform: translateX(5px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.1);
    }
    .species-name {
      font-weight: bold;
      margin-bottom: 5px;
      color: #1b5e20;
    }
    #abilities {
      background: rgba(0,0,0,0.05);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    .ability {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 8px 0;
    }
    #message {
      background: rgba(255,255,255,0.8);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      font-weight: bold;
      min-height: 20px;
      transition: all 0.3s;
    }
    #controls {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }
    button {
      background: linear-gradient(to bottom, #2e7d32, #1b5e20);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      flex: 1;
      margin: 0 5px;
    }
    button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.3);
    }
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    #score-display {
      font-size: 1.2em;
      font-weight: bold;
      margin: 10px 0;
    }
    #turn-counter {
      position: absolute;
      top: -25px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.9em;
    }
    .cooldown {
      font-size: 0.8em;
      color: #666;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0px); }
    }
    .floating {
      animation: float 3s ease-in-out infinite;
    }
    .highlight {
      background-color: #fff9c4;
      padding: 2px 5px;
      border-radius: 3px;
    }
    .progress-container {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 5px;
      margin: 5px 0;
    }
    .progress-bar {
      height: 10px;
      border-radius: 5px;
      background-color: #4caf50;
      width: 0%;
      transition: width 0.3s;
    }
  </style>
</head>
<body>
  <div id="header">
    <h1>üåø Tasmanian Tangle</h1>
    <p id="subtitle">Restore Tasmania's fragile ecosystems!</p>
  </div>

  <div id="game-container">
    <div id="board-container">
      <div id="turn-counter">Turn: <span id="turn-count">1</span>/20</div>
      <div id="board"></div>
    </div>
    
    <div id="sidebar">
      <div id="score-display">üèÜ Ecosystem Health: <span id="score">0</span>%</div>
      <div class="progress-container">
        <div id="health-bar" class="progress-bar"></div>
      </div>
      
      <div id="resources">
        <div class="resource">
          <div class="resource-icon">üíß</div>
          <div>Water Sources: <span id="water-count">0</span></div>
        </div>
        <div class="resource">
          <div class="resource-icon">‚òÄÔ∏è</div>
          <div>Sun Patches: <span id="sun-count">0</span></div>
        </div>
      </div>
      
      <div id="abilities">
        <h3>Tools:</h3>
        <div class="ability">
          <button id="bridge-btn" onclick="useTool('bridge')">üåâ Build Bridge</button>
          <span id="bridge-cooldown" class="cooldown"></span>
        </div>
        <div class="ability">
          <button id="clear-btn" onclick="useTool('clear')">üîÑ Clear Weeds</button>
          <span id="clear-cooldown" class="cooldown"></span>
        </div>
      </div>
      
      <div id="message">Select a native plant, then connect it to resources!</div>
      
      <h3>Native Species:</h3>
      <div id="species-list"></div>
      
      <div id="controls">
        <button onclick="endTurn()">End Turn</button>
        <button onclick="resetGame()">Restart</button>
      </div>
    </div>
  </div>

  <script>
    // ================
    // GAME CONFIG
    // ================
    const BOARD_SIZE = 8;
    const MAX_TURNS = 20;
    const SPECIES = [
      { 
        emoji: 'üåø', 
        name: 'Tasmanian Blue Gum', 
        needs: ['water'], 
        desc: 'Iconic tree that koalas depend on',
        rarity: 1
      },
      { 
        emoji: 'üå∏', 
        name: 'Leatherwood', 
        needs: ['water', 'sun'], 
        desc: 'Vital for native honey production',
        rarity: 2
      },
      { 
        emoji: 'üå≤', 
        name: 'Huon Pine', 
        needs: ['water'], 
        desc: 'One of the oldest living tree species',
        rarity: 3
      },
      { 
        emoji: 'üçÇ', 
        name: 'Waratah', 
        needs: ['sun'], 
        desc: 'Tasmania\'s floral emblem',
        rarity: 1
      }
    ];
    
    const THREATS = [
      { emoji: 'üî•', name: 'Bushfire', effect: 'Destroys paths and plants' },
      { emoji: 'ü¶ä', name: 'Fox', effect: 'Eats native animals' },
      { emoji: 'üåæ', name: 'Gorse', effect: 'Invasive weed that spreads fast' }
    ];

    // ================
    // GAME STATE
    // ================
    let board = [];
    let selectedTile = null;
    let score = 0;
    let turn = 1;
    let gameActive = true;
    let discoveredSpecies = [];
    let lastBridgeTurn = -3;
    let lastClearTurn = -5;
    let bridgeCooldown = 0;
    let clearCooldown = 0;

    // ================
    // INITIALIZATION
    // ================
    function initGame() {
      const boardElement = document.getElementById('board');
      boardElement.innerHTML = '';
      board = [];
      selectedTile = null;
      score = 0;
      turn = 1;
      gameActive = true;
      discoveredSpecies = [];
      lastBridgeTurn = -3;
      lastClearTurn = -5;
      updateScore();
      updateTurnCounter();
      updateCooldowns();
      
      // Create tiles
      for (let y = 0; y < BOARD_SIZE; y++) {
        board[y] = [];
        for (let x = 0; x < BOARD_SIZE; x++) {
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.dataset.x = x;
          tile.dataset.y = y;
          tile.addEventListener('click', () => handleTileClick(x, y));
          boardElement.appendChild(tile);
          board[y][x] = { 
            type: 'empty', 
            element: tile,
            revealed: false
          };
        }
      }

      // Place game elements with smart placement
      placeWithPathways();
      renderSpeciesList();
      showMessage("Welcome! Connect native plants to resources.", false);
    }

    function placeWithPathways() {
      // Place water and sun in connected clusters
      placeCluster('water', 'üíß', 3, 2);
      placeCluster('sun', '‚òÄÔ∏è', 3, 2);
      
      // Place plants near their required resources
      SPECIES.forEach(species => {
        const neededResources = species.needs;
        neededResources.forEach(resource => {
          placeNearResource('native', species.emoji, 2, resource);
        });
      });

      // Place weeds away from resources
      placeRandom('weed', getRandomThreat().emoji, 3, true);
    }

    function placeCluster(type, emoji, clusters, clusterSize) {
      for (let c = 0; c < clusters; c++) {
        const startX = Math.floor(Math.random() * (BOARD_SIZE - 2));
        const startY = Math.floor(Math.random() * (BOARD_SIZE - 2));
        
        for (let i = 0; i < clusterSize; i++) {
          const x = startX + Math.floor(Math.random() * 3);
          const y = startY + Math.floor(Math.random() * 3);
          if (board[y][x].type === 'empty') {
            convertTile(x, y, type, emoji);
          }
        }
      }
    }

    function placeNearResource(type, emoji, count, nearType) {
      let placed = 0;
      const attempts = 0;
      const maxAttempts = 20;
      
      while (placed < count && attempts < maxAttempts) {
        // Find random resource of nearType
        const resources = [];
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x].type === nearType) resources.push({x, y});
          }
        }
        
        if (resources.length > 0) {
          const {x: rx, y: ry} = resources[Math.floor(Math.random() * resources.length)];
          
          // Place in adjacent tile
          const directions = [
            {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
          ];
          
          for (const dir of directions) {
            const nx = rx + dir.dx;
            const ny = ry + dir.dy;
            if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                board[ny][nx].type === 'empty') {
              convertTile(nx, ny, type, emoji);
              placed++;
              break;
            }
          }
        }
        attempts++;
      }
      
      // Fallback to random placement
      while (placed < count) {
        placeRandom(type, emoji, 1);
        placed++;
      }
    }

    function placeRandom(type, emoji, count, avoidResources = false) {
      for (let i = 0; i < count; i++) {
        let x, y;
        let attempts = 0;
        const maxAttempts = 50;
        
        do {
          x = Math.floor(Math.random() * BOARD_SIZE);
          y = Math.floor(Math.random() * BOARD_SIZE);
          attempts++;
          
          if (attempts >= maxAttempts) break;
        } while (
          board[y][x].type !== 'empty' || 
          (avoidResources && isNearResource(x, y))
        );
        
        if (attempts < maxAttempts) {
          convertTile(x, y, type, emoji);
        }
      }
    }

    function isNearResource(x, y) {
      const directions = [
        {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1},
        {dx:1,dy:1}, {dx:-1,dy:1}, {dx:1,dy:-1}, {dx:-1,dy:-1}
      ];
      
      for (const dir of directions) {
        const nx = x + dir.dx;
        const ny = y + dir.dy;
        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
          if (board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
            return true;
          }
        }
      }
      return false;
    }

    function convertTile(x, y, type, emoji) {
      board[y][x].type = type;
      board[y][x].element.textContent = emoji;
      board[y][x].element.className = 'tile ' + type;
      
      // Special effects
      if (type === 'water') board[y][x].element.classList.add('floating');
      if (type === 'sun') {
        board[y][x].element.style.animation = `float 3s ease-in-out ${Math.random() * 2}s infinite`;
      }
    }

    // ================
    // GAME LOGIC
    // ================
    function handleTileClick(x, y) {
      if (!gameActive) return;
      
      const tile = board[y][x];
      
      // Select native plant
      if (tile.type === 'native') {
        if (selectedTile) selectedTile.element.classList.remove('selected');
        selectedTile = { 
          x, y, 
          element: tile.element,
          species: findSpecies(tile.element.textContent)
        };
        tile.element.classList.add('selected');
        
        // Discover new species
        if (!discoveredSpecies.includes(selectedTile.species.name)) {
          discoveredSpecies.push(selectedTile.species.name);
          renderSpeciesList();
          showMessage(`Discovered: ${selectedTile.species.name}! ${selectedTile.species.desc}`, false);
        } else {
          showMessage(`Selected: ${selectedTile.species.name}. Connect to ${selectedTile.species.needs.join(' and ')}.`, false);
        }
      } 
      // Connect to resource
      else if (selectedTile && (tile.type === 'water' || tile.type === 'sun')) {
        if (selectedTile.species.needs.includes(tile.type)) {
          if (connectTiles(selectedTile.x, selectedTile.y, x, y)) {
            selectedTile.element.classList.remove('selected');
            selectedTile = null;
          }
        } else {
          showMessage(`This plant doesn't need ${tile.type}!`, true);
        }
      }
      // Use bridge
      else if (selectedTile && tile.type === 'bridge') {
        if (connectThroughBridge(selectedTile.x, selectedTile.y, x, y)) {
          selectedTile.element.classList.remove('selected');
          selectedTile = null;
        }
      }
    }

    function connectTiles(x1, y1, x2, y2) {
      // Check if connection is possible
      if (!canConnect(x1, y1, x2, y2)) {
        showMessage("Cannot connect these tiles!", true);
        return false;
      }

      // Draw path with animation
      const path = getConnectionPath(x1, y1, x2, y2);
      if (!path) return false;

      path.forEach(({x, y}, i) => {
        setTimeout(() => {
          if (board[y][x].type === 'empty') {
            convertTile(x, y, 'path', 'üå±');
          }
        }, i * 100);
      });

      showMessage("üå± Connection growing...", false);
      checkGameState();
      return true;
    }

    function canConnect(x1, y1, x2, y2) {
      // Direct connection
      if (x1 === x2 || y1 === y2) {
        return hasClearPath(x1, y1, x2, y2);
      }
      // L-shaped connection
      return (
        (hasClearPath(x1, y1, x1, y2) && hasClearPath(x1, y2, x2, y2)) ||
        (hasClearPath(x1, y1, x2, y1) && hasClearPath(x2, y1, x2, y2))
      );
    }

    function getConnectionPath(x1, y1, x2, y2) {
      const path = [];
      
      // Vertical then horizontal
      if (hasClearPath(x1, y1, x1, y2) && hasClearPath(x1, y2, x2, y2)) {
        // Vertical segment
        const startY = Math.min(y1, y2);
        const endY = Math.max(y1, y2);
        for (let y = startY + 1; y < endY; y++) {
          path.push({x: x1, y});
        }
        // Horizontal segment
        const startX = Math.min(x1, x2);
        const endX = Math.max(x1, x2);
        for (let x = startX + 1; x < endX; x++) {
          path.push({x, y: y2});
        }
      }
      // Horizontal then vertical
      else if (hasClearPath(x1, y1, x2, y1) && hasClearPath(x2, y1, x2, y2)) {
        // Horizontal segment
        const startX = Math.min(x1, x2);
        const endX = Math.max(x1, x2);
        for (let x = startX + 1; x < endX; x++) {
          path.push({x, y: y1});
        }
        // Vertical segment
        const startY = Math.min(y1, y2);
        const endY = Math.max(y1, y2);
        for (let y = startY + 1; y < endY; y++) {
          path.push({x: x2, y});
        }
      }
      
      return path.length > 0 ? path : null;
    }

    function hasClearPath(x1, y1, x2, y2) {
      if (x1 === x2 && y1 === y2) return true;
      
      const dx = Math.sign(x2 - x1);
      const dy = Math.sign(y2 - y1);
      let x = x1 + dx;
      let y = y1 + dy;
      
      while (x !== x2 || y !== y2) {
        if (board[y][x].type === 'weed' || 
            (board[y][x].type !== 'empty' && board[y][x].type !== 'path' && board[y][x].type !== 'bridge')) {
          return false;
        }
        x += dx;
        y += dy;
      }
      
      return true;
    }

    function connectThroughBridge(x1, y1, x2, y2) {
      if (!selectedTile || board[y2][x2].type !== 'bridge') {
        showMessage("Select a plant and then click a bridge!", true);
        return false;
      }
      
      // Find what resource the bridge is connected to
      let resourceTile = null;
      const directions = [
        {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
      ];
      
      for (const dir of directions) {
        const nx = x2 + dir.dx;
        const ny = y2 + dir.dy;
        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
          if (board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
            resourceTile = {x: nx, y: ny, type: board[ny][nx].type};
            break;
          }
        }
      }
      
      if (!resourceTile) {
        showMessage("This bridge isn't connected to a resource!", true);
        return false;
      }
      
      // Check if plant needs this resource
      if (!selectedTile.species.needs.includes(resourceTile.type)) {
        showMessage(`This plant doesn't need ${resourceTile.type}!`, true);
        return false;
      }
      
      // Connect through bridge
      const path1 = getConnectionPath(x1, y1, x2, y2);
      const path2 = getConnectionPath(x2, y2, resourceTile.x, resourceTile.y);
      
      if (path1 && path2) {
        // Animate first path
        path1.forEach(({x, y}, i) => {
          setTimeout(() => {
            if (board[y][x].type === 'empty') {
              convertTile(x, y, 'path', 'üå±');
            }
          }, i * 100);
        });
        
        // Animate second path
        path2.forEach(({x, y}, i) => {
          setTimeout(() => {
            if (board[y][x].type === 'empty') {
              convertTile(x, y, 'path', 'üå±');
            }
          }, (path1.length + i) * 100);
        });
        
        showMessage("Connected through bridge!", false);
        checkGameState();
        return true;
      }
      
      showMessage("Cannot connect through this bridge!", true);
      return false;
    }

    function useTool(toolType) {
      if (!selectedTile) {
        showMessage("Select a tile first!", true);
        return;
      }

      const {x, y} = selectedTile;
      
      switch(toolType) {
        case 'bridge':
          if (turn - lastBridgeTurn < 3) {
            showMessage(`Bridge on cooldown! Wait ${3 - (turn - lastBridgeTurn)} more turns.`, true);
            return;
          }
          if (board[y][x].type !== 'empty') {
            showMessage("Can only build bridges on empty tiles!", true);
            return;
          }
          convertTile(x, y, 'bridge', 'üåâ');
          lastBridgeTurn = turn;
          updateCooldowns();
          showMessage("Built a bridge! Now connect plants through it.", false);
          break;
          
        case 'clear':
          if (turn - lastClearTurn < 5) {
            showMessage(`Weed clearing on cooldown! Wait ${5 - (turn - lastClearTurn)} more turns.`, true);
            return;
          }
          if (board[y][x].type !== 'weed') {
            showMessage("Can only clear weed tiles!", true);
            return;
          }
          convertTile(x, y, 'empty', '');
          lastClearTurn = turn;
          updateCooldowns();
          showMessage("Cleared weeds! Native plants can grow here now.", false);
          break;
      }
      
      selectedTile.element.classList.remove('selected');
      selectedTile = null;
    }

    function endTurn() {
      if (!gameActive) return;
      
      turn++;
      updateTurnCounter();
      updateCooldowns();
      
      // Weeds spread
      spreadWeeds();
      
      // Random events
      if (turn > 5 && Math.random() < 0.4) triggerRandomEvent();
      
      // Check win/lose
      checkGameState();
      
      // Respawn resources periodically
      if (turn % 4 === 0) respawnResources();
    }

    function spreadWeeds() {
      const newWeeds = [];
      const weedSpreadRate = Math.min(0.3 + (turn / 50), 0.7); // Increases over time
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'weed' && Math.random() < weedSpreadRate) {
            const directions = [
              {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
            ].sort(() => Math.random() - 0.5);
            
            for (const dir of directions) {
              const nx = x + dir.dx;
              const ny = y + dir.dy;
              if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                  board[ny][nx].type === 'empty') {
                newWeeds.push({x: nx, y: ny});
                break;
              }
            }
          }
        }
      }
      
      if (newWeeds.length > 0) {
        showMessage(`‚ö†Ô∏è Weeds spread to ${newWeeds.length} new areas!`, true);
        newWeeds.forEach(({x, y}) => {
          convertTile(x, y, 'weed', getRandomThreat().emoji);
        });
      }
    }

    function respawnResources() {
      const emptyTiles = getEmptyTiles();
      if (emptyTiles.length === 0) return;
      
      // Determine which resource to respawn
      const waterCount = countResources('water');
      const sunCount = countResources('sun');
      const respawnType = waterCount <= sunCount ? 'water' : 'sun';
      
      const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
      convertTile(x, y, respawnType, respawnType === 'water' ? 'üíß' : '‚òÄÔ∏è');
      showMessage(`üíß A new ${respawnType} source emerged!`, false);
      updateResourceCounts();
    }

    function triggerRandomEvent() {
      const events = [
        { 
          name: 'Rainfall', 
          effect: () => {
            const emptyTiles = getEmptyTiles();
            if (emptyTiles.length > 0) {
              const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
              convertTile(x, y, 'water', 'üíß');
              showMessage("üåßÔ∏è Rainfall created a new water source!", false);
              updateResourceCounts();
            }
          },
          chance: 0.6
        },
        {
          name: 'Drought',
          effect: () => {
            const waterTiles = [];
            for (let y = 0; y < BOARD_SIZE; y++) {
              for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'water') waterTiles.push({x, y});
              }
            }
            if (waterTiles.length > 1) {
              const {x, y} = waterTiles[Math.floor(Math.random() * waterTiles.length)];
              convertTile(x, y, 'empty', '');
              showMessage("‚òÄÔ∏è Drought dried up a water source!", true);
              updateResourceCounts();
            }
          },
          chance: 0.4
        }
      ];
      
      const event = events.find(e => Math.random() < e.chance) || events[0];
      event.effect();
    }

    function checkGameState() {
      // Check connected plants
      let connectedPlants = 0;
      let totalPlants = 0;
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'native') {
            totalPlants++;
            const species = findSpecies(board[y][x].element.textContent);
            let needsMet = 0;
            
            for (let ty = 0; ty < BOARD_SIZE; ty++) {
              for (let tx = 0; tx < BOARD_SIZE; tx++) {
                if (board[ty][tx].type === 'water' && species.needs.includes('water')) {
                  if (isConnected(x, y, tx, ty)) needsMet++;
                }
                if (board[ty][tx].type === 'sun' && species.needs.includes('sun')) {
                  if (isConnected(x, y, tx, ty)) needsMet++;
                }
              }
            }
            
            if (needsMet >= species.needs.length) connectedPlants++;
          }
        }
      }
      
      // Update score
      score = Math.floor((connectedPlants / totalPlants) * 100);
      updateScore();
      
      // Win/lose conditions
      if (score === 100) {
        gameActive = false;
        showMessage("üéâ You restored the ecosystem! All plants are thriving!", false);
      } else if (turn >= MAX_TURNS) {
        gameActive = false;
        showMessage(`üíÄ Time's up! You restored ${score}% of the ecosystem.`, true);
      }
    }

    function isConnected(x1, y1, x2, y2) {
      if (x1 === x2 && y1 === y2) return true;
      
      const visited = new Set();
      const queue = [{x: x1, y: y1}];
      visited.add(`${x1},${y1}`);
      
      while (queue.length > 0) {
        const {x, y} = queue.shift();
        const directions = [{dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}];
        
        for (const dir of directions) {
          const nx = x + dir.dx;
          const ny = y + dir.dy;
          const key = `${nx},${ny}`;
          
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && !visited.has(key)) {
            if (nx === x2 && ny === y2) return true;
            
            if (board[ny][nx].type === 'path' || board[ny][nx].type === 'bridge' || 
                board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
              visited.add(key);
              queue.push({x: nx, y: ny});
            }
          }
        }
      }
      
      return false;
    }

    // ================
    // UI UPDATES
    // ================
    function renderSpeciesList() {
      const list = document.getElementById('species-list');
      list.innerHTML = '';
      
      SPECIES.forEach(species => {
        const card = document.createElement('div');
        card.className = 'species-card';
        card.innerHTML = `
          <div class="species-name">${species.emoji} ${species.name}</div>
          <div style="font-size:0.9em; color:#666;">
            Needs: ${species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' + ')}
          </div>
          ${discoveredSpecies.includes(species.name) ? 
            `<div style="font-size:0.8em; margin-top:5px;">${species.desc}</div>` : 
            '<div style="font-size:0.8em; color:#999;">Not discovered yet</div>'}
        `;
        list.appendChild(card);
      });
    }

    function updateResourceCounts() {
      document.getElementById('water-count').textContent = countResources('water');
      document.getElementById('sun-count').textContent = countResources('sun');
    }

    function countResources(type) {
      let count = 0;
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === type) count++;
        }
      }
      return count;
    }

    function updateScore() {
      document.getElementById('score').textContent = score;
      document.getElementById('health-bar').style.width = `${score}%`;
      
      const scoreDisplay = document.getElementById('score-display');
      scoreDisplay.style.color = 
        score < 30 ? '#d32f2f' : score < 70 ? '#ff8f00' : '#2e7d32';
    }

    function updateTurnCounter() {
      document.getElementById('turn-count').textContent = turn;
      const counter = document.getElementById('turn-counter');
      counter.style.backgroundColor = 
        turn > MAX_TURNS - 5 ? 'rgba(211,47,47,0.8)' : 'rgba(0,0,0,0.7)';
    }

    function updateCooldowns() {
      bridgeCooldown = Math.max(0, 3 - (turn - lastBridgeTurn));
      clearCooldown = Math.max(0, 5 - (turn - lastClearTurn));
      
      document.getElementById('bridge-cooldown').textContent = 
        bridgeCooldown > 0 ? `${bridgeCooldown}turn${bridgeCooldown !== 1 ? 's' : ''}` : '';
      document.getElementById('clear-cooldown').textContent = 
        clearCooldown > 0 ? `${clearCooldown}turn${clearCooldown !== 1 ? 's' : ''}` : '';
      
      document.getElementById('bridge-btn').disabled = bridgeCooldown > 0;
      document.getElementById('clear-btn').disabled = clearCooldown > 0;
    }

    function showMessage(text, isWarning) {
      const msg = document.getElementById('message');
      msg.innerHTML = text;
      msg.style.background = isWarning ? 'rgba(255,205,210,0.8)' : 'rgba(200,230,201,0.8)';
      msg.style.color = isWarning ? '#d32f2f' : '#2e7d32';
    }

    // ================
    // HELPER FUNCTIONS
    // ================
    function getEmptyTiles() {
      const tiles = [];
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'empty') tiles.push({x, y});
        }
      }
      return tiles;
    }

    function getRandomSpecies() {
      // Weighted random based on rarity
      const pool = [];
      SPECIES.forEach(species => {
        for (let i = 0; i < (4 - species.rarity); i++) {
          pool.push(species);
        }
      });
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function getRandomThreat() {
      return THREATS[Math.floor(Math.random() * THREATS.length)];
    }

    function findSpecies(emoji) {
      return SPECIES.find(s => s.emoji === emoji) || SPECIES[0];
    }

    function resetGame() {
      initGame();
      showMessage("Game reset! Connect plants to resources.", false);
    }

    // Start the game
    initGame();
  </script>
</body>
</html>
