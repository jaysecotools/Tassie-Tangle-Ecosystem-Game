<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tassie Tangle Game - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a3c27 0%, #2d5a3d 100%);
            color: #e8f5e9;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        
        .game-header {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid #4caf50;
        }
        
        .game-title {
            font-size: 2.5em;
            color: #81c784;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            text-align: center;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #388e3c;
        }
        
        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #a5d6a7;
        }
        
        .main-game {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #4caf50;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin: 20px auto;
            max-width: 500px;
            background: rgba(76, 175, 80, 0.1);
            padding: 10px;
            border-radius: 8px;
            position: relative;
        }
        
        .tile {
            aspect-ratio: 1;
            background: #4caf50;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        .tile.empty { background: #2e7d32; }
        .tile.water { 
            background: #2196f3; 
            animation: float 3s ease-in-out infinite;
        }
        .tile.sun { 
            background: #ff9800; 
            animation: pulse 2s ease-in-out infinite;
        }
        .tile.native { background: #388e3c; }
        .tile.path { 
            background: #8bc34a; 
            font-size: 1.2em;
        }
        .tile.bridge { 
            background: #795548; 
            font-size: 1.2em;
        }
        .tile.weed { background: #d32f2f; }
        .tile.selected {
            box-shadow: 0 0 0 3px #ffeb3b, 0 0 20px rgba(255, 235, 59, 0.5);
            z-index: 10;
        }
        .tile.connected {
            box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.3);
        }
        
        /* Connection visualization */
        .connection-line {
            position: absolute;
            background: #ffeb3b;
            height: 4px;
            border-radius: 2px;
            pointer-events: none;
            z-index: 5;
            transform-origin: 0 0;
            box-shadow: 0 0 10px rgba(255, 235, 59, 0.7);
        }
        
        .connection-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff9800;
            border-radius: 50%;
            pointer-events: none;
            z-index: 6;
            animation: pulse-dot 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }
        
.tile.fully-connected {
    box-shadow: 
        inset 0 0 30px rgba(255, 255, 255, 0.7),
        0 0 0 4px #4caf50,
        0 0 25px rgba(76, 175, 80, 0.8);
    animation: fully-connected-glow 1.5s ease-in-out infinite alternate;
}

@keyframes fully-connected-glow {
    0% { box-shadow: 
        inset 0 0 25px rgba(255, 255, 255, 0.6),
        0 0 0 3px #4caf50,
        0 0 20px rgba(76, 175, 80, 0.7); }
    100% { box-shadow: 
        inset 0 0 35px rgba(255, 255, 255, 0.8),
        0 0 0 4px #4caf50,
        0 0 30px rgba(76, 175, 80, 0.9); }
}

        /* Better connected plant indicator */
        .tile.connected-plant {
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.5),
                0 0 0 3px #ffeb3b,
                0 0 20px rgba(255, 235, 59, 0.7);
            animation: glow-plant 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow-plant {
            0% { box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.5),
                0 0 0 3px #ffeb3b,
                0 0 20px rgba(255, 235, 59, 0.5); }
            100% { box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.7),
                0 0 0 3px #ffeb3b,
                0 0 30px rgba(255, 235, 59, 0.9); }
        }
        
        /* Resource connection indicator */
        .tile.connected-resource {
            animation: pulse-resource 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-resource {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Status indicator for connected plants */
        .plant-status {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6em;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        button {
            background: linear-gradient(145deg, #4caf50, #388e3c);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            justify-content: center;
            position: relative;
        }
        
        button:hover {
            background: linear-gradient(145deg, #66bb6a, #4caf50);
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        button.tool-btn {
            background: linear-gradient(145deg, #ff9800, #f57c00);
        }
        
        button.tool-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #ffb74d, #ff9800);
        }
        
        .sidebar {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #4caf50;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .instructions {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4caf50;
        }
        
        .instructions h3 {
            color: #81c784;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
            line-height: 1.6;
        }
        
        .species-list {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ff9800;
        }
        
        .species-list h3 {
            color: #ffb74d;
            margin-bottom: 10px;
        }
        
        .species-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .species-name {
            font-weight: bold;
            color: #a5d6a7;
            margin-bottom: 5px;
        }
        
        .message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(200, 230, 201, 0.95);
            color: #2e7d32;
            padding: 15px 25px;
            border-radius: 10px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 80%;
            text-align: center;
            transition: all 0.3s;
            border: 2px solid #4caf50;
        }
        
        .message-box.warning {
            background: rgba(255, 205, 210, 0.95);
            color: #d32f2f;
            border-color: #f44336;
        }
        
        .health-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #d32f2f, #ff9800, #4caf50);
            border-radius: 10px;
            transition: width 0.5s ease;
        }
        
        .level-up-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            text-align: center;
        }
        
        .level-up-content {
            background: linear-gradient(135deg, #1a3c27 0%, #2d5a3d 100%);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff9800;
            max-width: 500px;
            animation: popIn 0.5s ease-out;
        }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .resource-counts {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 10px 0;
        }
        
        .resource-count {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 20px;
        }
        
        .cooldown-display {
            font-size: 0.8em;
            color: #ff9800;
            margin-top: 4px;
        }
        
        /* Sound control */
        .sound-control {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            border: 2px solid #4caf50;
            font-size: 1.5em;
        }
        
        .sound-control:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="sound-control" id="sound-toggle" onclick="toggleSound()">
        <span id="sound-icon">üîä</span>
    </div>
    
    <div class="container">
        <div class="game-header">
            <h1 class="game-title">üåø Tassie Tangle</h1>
            <div class="stats">
                <div class="stat-box">
                    <div>Level</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat-box">
                    <div>Total Score</div>
                    <div class="stat-value" id="total-score-value">0</div>
                </div>
                <div class="stat-box">
                    <div>Health</div>
                    <div class="stat-value" id="score">0%</div>
                    <div class="health-bar">
                        <div class="health-fill" id="health-bar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-box">
                    <div>Turn</div>
                    <div class="stat-value" id="turn-count">1</div>
                    <div style="font-size:0.8em;color:#aaa;">of <span id="max-turns">20</span></div>
                </div>
            </div>
        </div>
        
        <div class="main-game">
            <div class="board" id="board">
                <!-- Board tiles will be generated here -->
            </div>
            
            <div class="controls">
                <button onclick="useTool('bridge')" class="tool-btn" id="bridge-btn">
                    üåâ Build Bridge
                    <div class="cooldown-display" id="bridge-cooldown"></div>
                </button>
                <button onclick="useTool('clear')" class="tool-btn" id="clear-btn">
                    üóëÔ∏è Clear Weeds
                    <div class="cooldown-display" id="clear-cooldown"></div>
                </button>
                <button onclick="endTurn()">
                    ‚è≠Ô∏è End Turn
                </button>
                <button onclick="resetGame()" style="background:linear-gradient(145deg,#f44336,#d32f2f);">
                    üîÑ Reset
                </button>
            </div>
            
            <div class="resource-counts">
                <div class="resource-count">
                    <span>üíß</span>
                    <span id="water-count">0</span>
                </div>
                <div class="resource-count">
                    <span>‚òÄÔ∏è</span>
                    <span id="sun-count">0</span>
                </div>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="instructions">
                <h3>How to Play</h3>
                <ul>
                    <li>Click on native plants (üåøüå∏üå≤üçÇ) to select them</li>
                    <li>Click on matching resources (üíß or ‚òÄÔ∏è) to connect</li>
                    <li>Plants need specific resources to survive</li>
                    <li>Clear weeds (üî•ü¶äüåæ) to make space</li>
                    <li>Use bridges to connect through obstacles</li>
                    <li>Complete connections before time runs out!</li>
                    <li><strong>Visual cues:</strong> Yellow lines = connections, ‚úì = plant satisfied</li>
                </ul>
            </div>
            
            <div class="species-list">
                <h3>Native Species</h3>
                <div id="species-list">
                    <!-- Species cards will be generated here -->
                </div>
            </div>
        </div>
    </div>
    
    <div id="level-up-screen" class="level-up-screen">
        <div class="level-up-content">
            <h2 style="font-size:3em;color:#ff9800;">LEVEL COMPLETE! üéâ</h2>
            <div style="font-size:1.5em;margin:20px 0;">
                You restored the ecosystem in <span id="completed-level">1</span>
            </div>
            <div style="font-size:1.2em;margin:20px 0;">
                Level Score: <span id="level-score" style="color:#ff9800;font-weight:bold;">0</span>
            </div>
            <div style="font-size:1.2em;margin:20px 0;">
                Total Score: <span id="new-total-score" style="color:#4caf50;font-weight:bold;">0</span>
            </div>
            <button onclick="startNextLevel()" style="font-size:1.2em;padding:15px 40px;margin-top:20px;">
                Start Level <span id="next-level">2</span> ‚Üí
            </button>
        </div>
    </div>
    
    <div id="message" class="message-box">
        Welcome to Tasmanian Ecosystem! Select a plant to begin.
    </div>

<script>
    // ================
    // GAME CONFIG
    // ================
    const BOARD_SIZE = 8;
    const BASE_TURNS = 20;
    const SPECIES = [
        { 
            emoji: 'üåø', 
            name: 'Tasmanian Blue Gum', 
            needs: ['water'], 
            desc: 'Iconic tree that koalas depend on',
            rarity: 1,
            points: 10
        },
        { 
            emoji: 'üå∏', 
            name: 'Leatherwood', 
            needs: ['water', 'sun'], 
            desc: 'Vital for native honey production',
            rarity: 2,
            points: 20
        },
        { 
            emoji: 'üå≤', 
            name: 'Huon Pine', 
            needs: ['water'], 
            desc: 'One of the oldest living tree species',
            rarity: 3,
            points: 15
        },
        { 
            emoji: 'üçÇ', 
            name: 'Waratah', 
            needs: ['sun'], 
            desc: 'Tasmania\'s floral emblem',
            rarity: 1,
            points: 10
        }
    ];
    
    const THREATS = [
        { emoji: 'üî•', name: 'Bushfire', effect: 'Destroys paths and plants' },
        { emoji: 'ü¶ä', name: 'Fox', effect: 'Eats native animals' },
        { emoji: 'üåæ', name: 'Gorse', effect: 'Invasive weed that spreads fast' }
    ];

    // ================
    // SOUND SYSTEM
    // ================
    let soundEnabled = true;
    let audioContext;
    let gainNode;
    let connectionLines = [];

    function initAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
            gainNode.gain.value = 0.3;
        } catch (e) {
            console.log("Web Audio API not supported");
            soundEnabled = false;
            document.getElementById('sound-toggle').style.display = 'none';
        }
    }

    function playSound(type) {
        if (!soundEnabled || !audioContext) return;
        
        const oscillator = audioContext.createOscillator();
        const envelope = audioContext.createGain();
        
        oscillator.connect(envelope);
        envelope.connect(gainNode);
        
        oscillator.type = 'square';
        
        switch(type) {
            case 'select':
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.3, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
                break;
                
            case 'connect':
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.4, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
                
                setTimeout(() => {
                    if (!soundEnabled) return;
                    const osc2 = audioContext.createOscillator();
                    const env2 = audioContext.createGain();
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(830.61, audioContext.currentTime);
                    env2.gain.setValueAtTime(0.2, audioContext.currentTime);
                    env2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    osc2.connect(env2);
                    env2.connect(gainNode);
                    osc2.start();
                    osc2.stop(audioContext.currentTime + 0.2);
                }, 100);
                break;
                
            case 'error':
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.4, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.15);
                
                setTimeout(() => {
                    if (!soundEnabled) return;
                    const osc2 = audioContext.createOscillator();
                    const env2 = audioContext.createGain();
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(174.61, audioContext.currentTime);
                    env2.gain.setValueAtTime(0.3, audioContext.currentTime);
                    env2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    osc2.connect(env2);
                    env2.connect(gainNode);
                    osc2.start();
                    osc2.stop(audioContext.currentTime + 0.1);
                }, 50);
                break;
                
            case 'tool':
                oscillator.frequency.setValueAtTime(392, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.3, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.25);
                break;
                
            case 'level':
                const notes = [523.25, 659.25, 783.99, 1046.50];
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        if (!soundEnabled) return;
                        const osc = audioContext.createOscillator();
                        const env = audioContext.createGain();
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        env.gain.setValueAtTime(0.3, audioContext.currentTime);
                        env.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                        osc.connect(env);
                        env.connect(gainNode);
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.15);
                    }, i * 150);
                });
                break;
                
            case 'weed':
                oscillator.frequency.setValueAtTime(146.83, audioContext.currentTime);
                envelope.gain.setValueAtTime(0.3, audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.4);
                break;
        }
    }

    function toggleSound() {
        soundEnabled = !soundEnabled;
        const icon = document.getElementById('sound-icon');
        icon.textContent = soundEnabled ? 'üîä' : 'üîá';
        
        if (soundEnabled && audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        if (soundEnabled) {
            playSound('select');
        }
    }

    // ================
    // CONNECTION VISUALIZATION
    // ================
    function drawConnectionLine(x1, y1, x2, y2) {
        const boardRect = document.getElementById('board').getBoundingClientRect();
        const tileSize = boardRect.width / BOARD_SIZE;
        
        const x1px = (x1 + 0.5) * tileSize;
        const y1px = (y1 + 0.5) * tileSize;
        const x2px = (x2 + 0.5) * tileSize;
        const y2px = (y2 + 0.5) * tileSize;
        
        const line = document.createElement('div');
        line.className = 'connection-line';
        
        const dx = x2px - x1px;
        const dy = y2px - y1px;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        
        line.style.width = `${length}px`;
        line.style.height = '4px';
        line.style.left = `${x1px}px`;
        line.style.top = `${y1px - 2}px`;
        line.style.transform = `rotate(${angle}deg)`;
        line.style.background = '#ffeb3b';
        line.style.opacity = '0.8';
        
        const dot1 = document.createElement('div');
        dot1.className = 'connection-dot';
        dot1.style.left = `${x1px - 4}px`;
        dot1.style.top = `${y1px - 4}px`;
        
        const dot2 = document.createElement('div');
        dot2.className = 'connection-dot';
        dot2.style.left = `${x2px - 4}px`;
        dot2.style.top = `${y2px - 4}px`;
        
        const board = document.getElementById('board');
        board.appendChild(line);
        board.appendChild(dot1);
        board.appendChild(dot2);
        
        connectionLines.push({line, dots: [dot1, dot2]});
    }

    function clearConnectionVisuals() {
        connectionLines.forEach(({line, dots}) => {
            if (line.parentNode) line.parentNode.removeChild(line);
            dots.forEach(dot => {
                if (dot.parentNode) dot.parentNode.removeChild(dot);
            });
        });
        connectionLines = [];
    }

    function updateConnectionVisuals() {
        clearConnectionVisuals();
        
        connections.forEach(conn => {
            const [from, to] = conn.split('-');
            const [x1, y1] = from.split(',').map(Number);
            const [x2, y2] = to.split(',').map(Number);
            
            drawConnectionLine(x1, y1, x2, y2);
        });
        
        updatePlantStatusIndicators();
    }

    function updatePlantStatusIndicators() {
        document.querySelectorAll('.plant-status').forEach(el => el.remove());
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'native') {
                    const species = findSpecies(board[y][x].element.textContent);
let needsMet = 0;
let waterConnected = false;
let sunConnected = false;

if (species.needs.includes('water')) {
    for (let ty = 0; ty < BOARD_SIZE; ty++) {
        for (let tx = 0; tx < BOARD_SIZE; tx++) {
            if (board[ty][tx].type === 'water' && isConnected(x, y, tx, ty)) {
                waterConnected = true;
                needsMet++;
                break;
            }
        }
        if (waterConnected) break;
    }
}

if (species.needs.includes('sun')) {
    for (let ty = 0; ty < BOARD_SIZE; ty++) {
        for (let tx = 0; tx < BOARD_SIZE; tx++) {
            if (board[ty][tx].type === 'sun' && isConnected(x, y, tx, ty)) {
                sunConnected = true;
                needsMet++;
                break;
            }
        }
        if (sunConnected) break;
    }
}
                    
                    const tile = board[y][x].element;
                    const status = document.createElement('div');
                    status.className = 'plant-status';
                    
                    if (needsMet >= species.needs.length) {
                        status.textContent = '‚úì';
                        status.style.color = '#4caf50';
                        status.style.background = 'rgba(76, 175, 80, 0.9)';
                        tile.classList.add('connected-plant');
                        tile.classList.remove('connected');
                    } else if (needsMet > 0) {
                        status.textContent = `${needsMet}/${species.needs.length}`;
                        status.style.color = '#ff9800';
                        status.style.background = 'rgba(255, 152, 0, 0.9)';
                        tile.classList.remove('connected-plant', 'connected');
                    } else {
                        status.textContent = '!';
                        status.style.color = '#f44336';
                        status.style.background = 'rgba(244, 67, 54, 0.9)';
                        tile.classList.remove('connected-plant', 'connected');
                    }
                    
                    tile.appendChild(status);
                    
                    for (let ty = 0; ty < BOARD_SIZE; ty++) {
                        for (let tx = 0; tx < BOARD_SIZE; tx++) {
                            if ((board[ty][tx].type === 'water' || board[ty][tx].type === 'sun') && 
                                isConnected(x, y, tx, ty)) {
                                board[ty][tx].element.classList.add('connected-resource');
                            } else {
                                board[ty][tx].element.classList.remove('connected-resource');
                            }
                        }
                    }
                }
            }
        }
    }

    // ================
    // GAME STATE
    // ================
    let board = [];
    let selectedTile = null;
    let score = 0;
    let turn = 1;
    let gameActive = true;
    let discoveredSpecies = [];
    let lastBridgeTurn = -3;
    let lastClearTurn = -5;
    let bridgeCooldown = 0;
    let clearCooldown = 0;
    let connections = [];
    let multiplier = 1;
    let level = 1;
    let totalScore = 0;
    let levelScore = 0;
    let maxTurns = BASE_TURNS;

    // ================
    // INITIALIZATION
    // ================
    function initGame() {
        initAudio();
        
        const boardElement = document.getElementById('board');
        boardElement.innerHTML = '';
        board = [];
        selectedTile = null;
        score = 0;
        levelScore = 0;
        turn = 1;
        gameActive = true;
        discoveredSpecies = [];
        lastBridgeTurn = -3;
        lastClearTurn = -5;
        connections = [];
        multiplier = 1;
        
        clearConnectionVisuals();
        
        maxTurns = Math.max(10, BASE_TURNS - Math.floor(level / 2));
        
        updateScore();
        updateTurnCounter();
        updateCooldowns();
        updateLevelDisplay();
        updateTotalScore();
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            board[y] = [];
            for (let x = 0; x < BOARD_SIZE; x++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.x = x;
                tile.dataset.y = y;
                tile.addEventListener('click', () => handleTileClick(x, y));
                boardElement.appendChild(tile);
                board[y][x] = { 
                    type: 'empty', 
                    element: tile,
                    revealed: false,
                    connected: false,
                    x: x,
                    y: y
                };
            }
        }

        placeWithPathways();
        renderSpeciesList();
        showMessage(`Level ${level}: Connect plants to resources!`, false);
        updateResourceCounts();
        
        setTimeout(() => playSound('select'), 300);
    }

    function placeWithPathways() {
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                board[y][x].type = 'empty';
                board[y][x].element.textContent = '';
                board[y][x].element.className = 'tile';
                board[y][x].connected = false;
            }
        }
        
        const resourceClusters = Math.max(2, 4 - Math.floor(level / 3));
        placeCluster('water', 'üíß', resourceClusters, 3);
        placeCluster('sun', '‚òÄÔ∏è', resourceClusters, 3);
        
        const plantsPerSpecies = 1 + Math.floor(level / 2);
        SPECIES.forEach(species => {
            placeNearResource('native', species.emoji, plantsPerSpecies, species.needs[0]);
        });

        const initialWeeds = 3 + level;
        placeRandom('weed', getRandomThreat().emoji, initialWeeds, true);
    }

    function placeCluster(type, emoji, clusters, clusterSize) {
        for (let c = 0; c < clusters; c++) {
            const startX = Math.floor(Math.random() * (BOARD_SIZE - 3)) + 1;
            const startY = Math.floor(Math.random() * (BOARD_SIZE - 3)) + 1;
            
            for (let i = 0; i < clusterSize; i++) {
                const x = startX + Math.floor(Math.random() * 3) - 1;
                const y = startY + Math.floor(Math.random() * 3) - 1;
                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE && board[y][x].type === 'empty') {
                    convertTile(x, y, type, emoji);
                }
            }
        }
    }

    function placeNearResource(type, emoji, count, nearType) {
        let placed = 0;
        const maxAttempts = 50;
        
        for (let attempt = 0; attempt < maxAttempts && placed < count; attempt++) {
            const resources = [];
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (board[y][x].type === nearType) resources.push({x, y});
                }
            }
            
            if (resources.length === 0) break;
            
            const {x: rx, y: ry} = resources[Math.floor(Math.random() * resources.length)];
            
            const directions = [
                {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1},
                {dx:1,dy:1}, {dx:-1,dy:1}, {dx:1,dy:-1}, {dx:-1,dy:-1}
            ].sort(() => Math.random() - 0.5);
            
            for (const dir of directions) {
                const nx = rx + dir.dx;
                const ny = ry + dir.dy;
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                    board[ny][nx].type === 'empty') {
                    convertTile(nx, ny, type, emoji);
                    placed++;
                    break;
                }
            }
        }
        
        if (placed < count) {
            const remaining = count - placed;
            placeRandom(type, emoji, remaining);
            placed += remaining;
        }
    }

    function placeRandom(type, emoji, count, avoidResources = false) {
        const emptyTiles = [];
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'empty') {
                    if (!avoidResources || !isNearResource(x, y)) {
                        emptyTiles.push({x, y});
                    }
                }
            }
        }
        
        shuffleArray(emptyTiles);
        for (let i = 0; i < Math.min(count, emptyTiles.length); i++) {
            const {x, y} = emptyTiles[i];
            convertTile(x, y, type, emoji);
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function isNearResource(x, y) {
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                    if (board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function convertTile(x, y, type, emoji) {
        board[y][x].type = type;
        board[y][x].element.textContent = emoji;
        board[y][x].element.className = 'tile ' + type;
        
        board[y][x].element.querySelectorAll('.plant-status').forEach(el => el.remove());
        board[y][x].element.classList.remove('connected-plant', 'connected-resource');
        
        if (type === 'water') {
            board[y][x].element.style.animation = 'float 3s ease-in-out infinite';
        }
        if (type === 'sun') {
            board[y][x].element.style.animation = 'pulse 2s ease-in-out infinite';
        }
        
        board[y][x].connected = (type === 'path' || type === 'bridge');
    }

    // ================
    // GAME LOGIC
    // ================
function handleTileClick(x, y) {
    if (!gameActive) return;
    
    const tile = board[y][x];
    const prevSelected = selectedTile;
    
    // If clicking the same tile again, deselect it
    if (selectedTile && selectedTile.x === x && selectedTile.y === y) {
        selectedTile.element.classList.remove('selected');
        selectedTile = null;
        showMessage("Tile deselected.", false);
        return;
    }
    
    // If we already have a selected plant AND click on a water/sun resource, try to connect
    if (prevSelected && (tile.type === 'water' || tile.type === 'sun')) {
        // Check if previous selection was a plant
        if (board[prevSelected.y][prevSelected.x].type === 'native') {
            const plantSpecies = findSpecies(board[prevSelected.y][prevSelected.x].element.textContent);
            
            if (plantSpecies.needs.includes(tile.type)) {
                if (connectTiles(prevSelected.x, prevSelected.y, x, y)) {
                    // Success! Remove selection from plant
                    prevSelected.element.classList.remove('selected');
                    selectedTile = null;
                }
                return; // Don't select the resource tile
            } else {
                playSound('error');
                const needsStr = plantSpecies.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' and ');
                showMessage(`This plant doesn't need ${tile.type}! It needs ${needsStr}.`, true);
                // Keep plant selected
                return;
            }
        }
    }
    
    // If we already have a selected plant AND click on a bridge, try to connect through bridge
    if (prevSelected && tile.type === 'bridge') {
        if (board[prevSelected.y][prevSelected.x].type === 'native') {
            const success = connectThroughBridge(prevSelected.x, prevSelected.y, x, y);
            if (success) {
                // Connection successful - keep plant selected for potential more connections
                // Don't change selection
                return;
            } else {
                // Connection failed - keep plant selected
                selectedTile = prevSelected;
                selectedTile.element.classList.add('selected');
                return;
            }
        }
    }
    
    // Clear previous selection
    if (selectedTile) {
        selectedTile.element.classList.remove('selected');
    }
    
    // Select the clicked tile
    selectedTile = { 
        x, y, 
        element: tile.element,
        species: tile.type === 'native' ? findSpecies(tile.element.textContent) : null
    };
    tile.element.classList.add('selected');
    
    // Handle based on tile type
    if (tile.type === 'native') {
        const species = selectedTile.species;
        
        // Check if already fully connected
// Check if already fully connected
let waterConnected = false;
let sunConnected = false;

if (species.needs.includes('water')) {
    for (let ty = 0; ty < BOARD_SIZE; ty++) {
        for (let tx = 0; tx < BOARD_SIZE; tx++) {
            if (board[ty][tx].type === 'water' && isConnected(x, y, tx, ty)) {
                waterConnected = true;
                break;
            }
        }
        if (waterConnected) break;
    }
} else {
    waterConnected = true; // Doesn't need water
}

if (species.needs.includes('sun')) {
    for (let ty = 0; ty < BOARD_SIZE; ty++) {
        for (let tx = 0; tx < BOARD_SIZE; tx++) {
            if (board[ty][tx].type === 'sun' && isConnected(x, y, tx, ty)) {
                sunConnected = true;
                break;
            }
        }
        if (sunConnected) break;
    }
} else {
    sunConnected = true; // Doesn't need sun
}

const isFullyConnected = (!species.needs.includes('water') || waterConnected) && 
                         (!species.needs.includes('sun') || sunConnected);        
        if (isFullyConnected) {
            playSound('error');
            showMessage("This plant is already fully connected! Try another plant.", true);
        } else {
            playSound('select');
            const speciesName = species.name;
            if (!discoveredSpecies.includes(speciesName)) {
                discoveredSpecies.push(speciesName);
                renderSpeciesList();
                showMessage(`Discovered: ${speciesName}! ${species.desc}`, false);
            } else {
                const needsStr = species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' and ');
                showMessage(`Selected: ${speciesName}. Needs: ${needsStr}.`, false);
            }
        }
    } 
    else if (tile.type === 'water' || tile.type === 'sun') {
        // If we get here, it means we selected a resource without a plant selected first
        showMessage(`Selected ${tile.type} source. Now select a plant that needs it.`, false);
    }
    else if (tile.type === 'bridge') {
        showMessage(`Selected bridge. Now select a plant to connect through it.`, false);
    }
    else if (tile.type === 'empty') {
        showMessage(`Selected empty tile. Use Bridge tool here to build a bridge.`, false);
    }
    else if (tile.type === 'weed') {
        showMessage(`Selected weed tile. Use Clear Weeds tool to remove it.`, false);
    }
    else if (tile.type === 'path') {
        showMessage(`Selected path tile.`, false);
    }
}    function connectTiles(x1, y1, x2, y2) {
        const path = findConnectionPath(x1, y1, x2, y2);
        if (!path) {
            playSound('error');
            showMessage("Cannot connect these tiles! Path is blocked.", true);
            return false;
        }

        const connectionKey = `${x1},${y1}-${x2},${y2}`;
        const reverseKey = `${x2},${y2}-${x1},${y1}`;
        if (connections.includes(connectionKey) || connections.includes(reverseKey)) {
            playSound('error');
            showMessage("These are already connected!", true);
            return false;
        }

        connections.push(connectionKey);

        path.forEach(({x, y}, i) => {
            setTimeout(() => {
                if (board[y][x].type === 'empty') {
                    convertTile(x, y, 'path', 'üå±');
                }
            }, i * 100);
        });

        setTimeout(() => {
            board[y1][x1].connected = true;
            board[y2][x2].connected = true;
            
            checkPlantNeeds(x1, y1);
            
            updateConnectionVisuals();
            
            playSound('connect');
            showMessage("üå± Connection successful!", false);
            checkGameState();
        }, path.length * 100 + 200);

        return true;
    }

    function findConnectionPath(x1, y1, x2, y2) {
        if (y1 === y2) {
            const path = getStraightPath(x1, y1, x2, y2, true);
            if (path) return path;
        }
        
        if (x1 === x2) {
            const path = getStraightPath(x1, y1, x2, y2, false);
            if (path) return path;
        }
        
        const path1 = getLShapedPath(x1, y1, x2, y2, true);
        if (path1) return path1;
        
        const path2 = getLShapedPath(x1, y1, x2, y2, false);
        if (path2) return path2;
        
        return null;
    }

    function getStraightPath(x1, y1, x2, y2, isHorizontal) {
        const path = [];
        
        if (isHorizontal) {
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);
            const y = y1;
            
            for (let x = startX + 1; x < endX; x++) {
                if (!isTilePassable(x, y, true)) return null;
                path.push({x, y});
            }
        } else {
            const startY = Math.min(y1, y2);
            const endY = Math.max(y1, y2);
            const x = x1;
            
            for (let y = startY + 1; y < endY; y++) {
                if (!isTilePassable(x, y, true)) return null;
                path.push({x, y});
            }
        }
        
        return path;
    }

    function getLShapedPath(x1, y1, x2, y2, horizontalFirst) {
        const path = [];
        let cornerX, cornerY;
        
        if (horizontalFirst) {
            cornerX = x2;
            cornerY = y1;
            
            const hStartX = Math.min(x1, cornerX);
            const hEndX = Math.max(x1, cornerX);
            for (let x = hStartX + 1; x < hEndX; x++) {
                if (!isTilePassable(x, cornerY, true)) return null;
                path.push({x, y: cornerY});
            }
            
            const vStartY = Math.min(cornerY, y2);
            const vEndY = Math.max(cornerY, y2);
            for (let y = vStartY + 1; y < vEndY; y++) {
                if (!isTilePassable(cornerX, y, true)) return null;
                path.push({x: cornerX, y});
            }
        } else {
            cornerX = x1;
            cornerY = y2;
            
            const vStartY = Math.min(y1, cornerY);
            const vEndY = Math.max(y1, cornerY);
            for (let y = vStartY + 1; y < vEndY; y++) {
                if (!isTilePassable(cornerX, y, true)) return null;
                path.push({x: cornerX, y});
            }
            
            const hStartX = Math.min(cornerX, x2);
            const hEndX = Math.max(cornerX, x2);
            for (let x = hStartX + 1; x < hEndX; x++) {
                if (!isTilePassable(x, cornerY, true)) return null;
                path.push({x, y: cornerY});
            }
        }
        
        return path;
    }

    function isTilePassable(x, y, forPath) {
        if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return false;
        
        const tileType = board[y][x].type;
        
        if (forPath) {
            return tileType === 'empty' || tileType === 'path' || tileType === 'bridge';
        }
        
        return tileType === 'empty';
    }

function connectThroughBridge(x1, y1, x2, y2) {
    // x1, y1 should be the plant coordinates, x2, y2 should be the bridge coordinates
    // Check if the source is actually a plant
    if (board[y1][x1].type !== 'native') {
        showMessage("Select a plant first, then click a bridge!", true);
        return false;
    }
    
    // Check if the destination is actually a bridge
    if (board[y2][x2].type !== 'bridge') {
        showMessage("This is not a bridge!", true);
        return false;
    }
    
    // Find a resource connected to this bridge
    let resourceTile = null;
    const directions = [
        {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
    ];
    
    // First, check if bridge is already connected to a resource
    for (const dir of directions) {
        const nx = x2 + dir.dx;
        const ny = y2 + dir.dy;
        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
            if (board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
                resourceTile = {x: nx, y: ny, type: board[ny][nx].type};
                break;
            }
        }
    }
    
    // If not directly adjacent, check if bridge is connected to a path that leads to a resource
    if (!resourceTile) {
        // We need to find any resource that's connected to this bridge
        for (let ty = 0; ty < BOARD_SIZE; ty++) {
            for (let tx = 0; tx < BOARD_SIZE; tx++) {
                if ((board[ty][tx].type === 'water' || board[ty][tx].type === 'sun') && 
                    isConnected(x2, y2, tx, ty)) {
                    resourceTile = {x: tx, y: ty, type: board[ty][tx].type};
                    break;
                }
            }
            if (resourceTile) break;
        }
    }
    
    if (!resourceTile) {
        showMessage("This bridge isn't connected to any resource!", true);
        return false;
    }
    
    // Check if the plant needs this type of resource
    const plantSpecies = findSpecies(board[y1][x1].element.textContent);
    if (!plantSpecies.needs.includes(resourceTile.type)) {
        const needsStr = plantSpecies.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' and ');
        showMessage(`This plant doesn't need ${resourceTile.type}! It needs ${needsStr}.`, true);
        return false;
    }
    
    // Check if plant is already connected to this resource
    if (isConnected(x1, y1, resourceTile.x, resourceTile.y)) {
        showMessage("This plant is already connected to that resource!", true);
        return false;
    }
    
    // Find paths from plant to bridge and from bridge to resource
    const path1 = findConnectionPath(x1, y1, x2, y2);
    const path2 = findConnectionPath(x2, y2, resourceTile.x, resourceTile.y);
    
    if (path1 && path2) {
        const connectionKey = `${x1},${y1}-${resourceTile.x},${resourceTile.y}`;
        const reverseKey = `${resourceTile.x},${resourceTile.y}-${x1},${y1}`;
        
        if (connections.includes(connectionKey) || connections.includes(reverseKey)) {
            playSound('error');
            showMessage("These are already connected!", true);
            return false;
        }
        
        connections.push(connectionKey);
        
        // Create path from plant to bridge
        path1.forEach(({x, y}, i) => {
            setTimeout(() => {
                if (board[y][x].type === 'empty') {
                    convertTile(x, y, 'path', 'üå±');
                }
            }, i * 100);
        });
        
        // Create path from bridge to resource
        path2.forEach(({x, y}, i) => {
            setTimeout(() => {
                if (board[y][x].type === 'empty') {
                    convertTile(x, y, 'path', 'üå±');
                }
            }, (path1.length + i) * 100);
        });
        
        setTimeout(() => {
            board[y1][x1].connected = true;
            board[resourceTile.y][resourceTile.x].connected = true;
            
            checkPlantNeeds(x1, y1);
            showMessage("Connected through bridge!", false);
            updateConnectionVisuals();
            checkGameState();
            playSound('connect');
        }, (path1.length + path2.length) * 100 + 200);
        
        return true;
    }
    
    showMessage("Cannot connect through this bridge! Path is blocked.", true);
    return false;
}
function checkPlantNeeds(x, y) {
    if (board[y][x].type !== 'native') return;
    
    const species = findSpecies(board[y][x].element.textContent);
    let waterConnected = false;
    let sunConnected = false;
    
    if (species.needs.includes('water')) {
        for (let ty = 0; ty < BOARD_SIZE; ty++) {
            for (let tx = 0; tx < BOARD_SIZE; tx++) {
                if (board[ty][tx].type === 'water' && isConnected(x, y, tx, ty)) {
                    waterConnected = true;
                    break;
                }
            }
            if (waterConnected) break;
        }
    }
    
    if (species.needs.includes('sun')) {
        for (let ty = 0; ty < BOARD_SIZE; ty++) {
            for (let tx = 0; tx < BOARD_SIZE; tx++) {
                if (board[ty][tx].type === 'sun' && isConnected(x, y, tx, ty)) {
                    sunConnected = true;
                    break;
                }
            }
            if (sunConnected) break;
        }
    }
    
    // Only award points if ALL needs are met
    const needsMet = (!species.needs.includes('water') || waterConnected) && 
                     (!species.needs.includes('sun') || sunConnected);
    
    if (needsMet && !board[y][x].element.classList.contains('fully-connected')) {
        board[y][x].element.classList.add('fully-connected');
        multiplier += 0.2;
        const pointsEarned = Math.floor(species.points * multiplier);
        levelScore += pointsEarned;
        totalScore += pointsEarned;
        updateTotalScore();
        updateScore();
        showMessage(`Great job! ${species.name} is thriving! +${pointsEarned} points (x${multiplier.toFixed(1)})`, false);
    }
    
    updateConnectionVisuals();
}
    function useTool(toolType) {
        if (!selectedTile) {
            playSound('error');
            showMessage("Select a tile first!", true);
            return;
        }

        const {x, y} = selectedTile;
        
        switch(toolType) {
            case 'bridge':
                if (turn - lastBridgeTurn < 3) {
                    playSound('error');
                    showMessage(`Bridge on cooldown! Wait ${3 - (turn - lastBridgeTurn)} more turns.`, true);
                    return;
                }
                if (board[y][x].type !== 'empty') {
                    playSound('error');
                    showMessage("Can only build bridges on empty tiles!", true);
                    return;
                }
                convertTile(x, y, 'bridge', 'üåâ');
                lastBridgeTurn = turn;
                updateCooldowns();
                playSound('tool');
                showMessage("Built a bridge! Now connect plants through it.", false);
                break;
                
            case 'clear':
                if (turn - lastClearTurn < 5) {
                    playSound('error');
                    showMessage(`Weed clearing on cooldown! Wait ${5 - (turn - lastClearTurn)} more turns.`, true);
                    return;
                }
                if (board[y][x].type !== 'weed') {
                    playSound('error');
                    showMessage("Can only clear weed tiles!", true);
                    return;
                }
                convertTile(x, y, 'empty', '');
                lastClearTurn = turn;
                updateCooldowns();
                playSound('tool');
                showMessage("Cleared weeds! Native plants can grow here now.", false);
                break;
        }
        
        selectedTile.element.classList.remove('selected');
        selectedTile = null;
        updateConnectionVisuals();
    }

    function endTurn() {
        if (!gameActive) return;
        
        turn++;
        updateTurnCounter();
        updateCooldowns();
        
        const weedSpreadRate = Math.min(0.2 + (level / 10) + (turn / 40), 0.7);
        spreadWeeds(weedSpreadRate);
        
        if (turn > 3 && Math.random() < 0.3 + (level * 0.02)) triggerRandomEvent();
        
        checkGameState();
        
        if (turn % Math.max(1, 4 - Math.floor(level / 5)) === 0) respawnResources();
        
        showMessage(`Turn ${turn} started. Connect more plants!`, false);
        playSound('select');
    }

    function spreadWeeds(spreadRate) {
        const newWeeds = [];
        
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'weed' && Math.random() < spreadRate) {
                    const directions = [
                        {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
                    ].sort(() => Math.random() - 0.5);
                    
                    for (const dir of directions) {
                        const nx = x + dir.dx;
                        const ny = y + dir.dy;
                        if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                            board[ny][nx].type === 'empty') {
                            newWeeds.push({x: nx, y: ny});
                            break;
                        }
                    }
                }
            }
        }
        
        if (newWeeds.length > 0) {
            showMessage(`‚ö†Ô∏è Weeds spread to ${newWeeds.length} new areas!`, true);
            newWeeds.forEach(({x, y}) => {
                convertTile(x, y, 'weed', getRandomThreat().emoji);
            });
        }
        
        updateConnectionVisuals();
    }

    function respawnResources() {
        const emptyTiles = getEmptyTiles();
        if (emptyTiles.length === 0) return;
        
        const waterCount = countResources('water');
        const sunCount = countResources('sun');
        const respawnType = waterCount <= sunCount ? 'water' : 'sun';
        
        let placed = false;
        const resources = [];
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === respawnType) resources.push({x, y});
            }
        }
        
        if (resources.length > 0) {
            const {x: rx, y: ry} = resources[Math.floor(Math.random() * resources.length)];
            const directions = [
                {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
            ].sort(() => Math.random() - 0.5);
            
            for (const dir of directions) {
                const nx = rx + dir.dx;
                const ny = ry + dir.dy;
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
                    board[ny][nx].type === 'empty') {
                    convertTile(nx, ny, respawnType, respawnType === 'water' ? 'üíß' : '‚òÄÔ∏è');
                    placed = true;
                    break;
                }
            }
        }
        
        if (!placed) {
            const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            convertTile(x, y, respawnType, respawnType === 'water' ? 'üíß' : '‚òÄÔ∏è');
        }
        
        showMessage(`A new ${respawnType} source emerged!`, false);
        updateResourceCounts();
        updateConnectionVisuals();
    }

    function triggerRandomEvent() {
        const events = [
            { 
                name: 'Rainfall', 
                effect: () => {
                    const emptyTiles = getEmptyTiles();
                    if (emptyTiles.length > 0) {
                        const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                        convertTile(x, y, 'water', 'üíß');
                        showMessage("üåßÔ∏è Rainfall created a new water source!", false);
                        updateResourceCounts();
                    }
                },
                chance: 0.5
            },
            {
                name: 'Drought',
                effect: () => {
                    const waterTiles = [];
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x].type === 'water') waterTiles.push({x, y});
                        }
                    }
                    if (waterTiles.length > 1) {
                        const {x, y} = waterTiles[Math.floor(Math.random() * waterTiles.length)];
                        convertTile(x, y, 'empty', '');
                        showMessage("‚òÄÔ∏è Drought dried up a water source!", true);
                        updateResourceCounts();
                    }
                },
                chance: 0.3
            },
            {
                name: 'Sunny Break',
                effect: () => {
                    const emptyTiles = getEmptyTiles();
                    if (emptyTiles.length > 0) {
                        const {x, y} = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                        convertTile(x, y, 'sun', '‚òÄÔ∏è');
                        showMessage("‚òÄÔ∏è Sunshine created a new sunny patch!", false);
                        updateResourceCounts();
                    }
                },
                chance: 0.5
            },
            {
                name: 'Wildfire',
                effect: () => {
                    const destroyChance = 0.2 + (level * 0.02);
                    let pathsDestroyed = 0;
                    for (let y = 0; y < BOARD_SIZE; y++) {
                        for (let x = 0; x < BOARD_SIZE; x++) {
                            if (board[y][x].type === 'path' && Math.random() < destroyChance) {
                                convertTile(x, y, 'empty', '');
                                pathsDestroyed++;
                            }
                        }
                    }
                    showMessage(`üî• Wildfire destroyed ${pathsDestroyed} paths!`, true);
                    checkGameState();
                },
                chance: 0.2
            },
            {
                name: 'Invasive Species',
                effect: () => {
                    const newWeeds = 1 + Math.floor(level / 2);
                    placeRandom('weed', getRandomThreat().emoji, newWeeds);
                    showMessage(`‚ö†Ô∏è Invasive species spread ${newWeeds} new weeds!`, true);
                },
                chance: 0.3
            }
        ];
        
        let total = 0;
        const randomValue = Math.random();
        let selectedEvent = events[0];
        
        for (const event of events) {
            total += event.chance;
            if (randomValue <= total) {
                selectedEvent = event;
                break;
            }
        }
        
        selectedEvent.effect();
        updateConnectionVisuals();
    }

function checkGameState() {
    let connectedPlants = 0;
    let totalPlants = 0;
    
    for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x].type === 'native') {
                totalPlants++;
                const species = findSpecies(board[y][x].element.textContent);
                let waterConnected = false;
                let sunConnected = false;
                
                // Check water connection if needed
                if (species.needs.includes('water')) {
                    for (let ty = 0; ty < BOARD_SIZE; ty++) {
                        for (let tx = 0; tx < BOARD_SIZE; tx++) {
                            if (board[ty][tx].type === 'water' && isConnected(x, y, tx, ty)) {
                                waterConnected = true;
                                break;
                            }
                        }
                        if (waterConnected) break;
                    }
                } else {
                    waterConnected = true; // Doesn't need water, so consider it "connected"
                }
                
                // Check sun connection if needed
                if (species.needs.includes('sun')) {
                    for (let ty = 0; ty < BOARD_SIZE; ty++) {
                        for (let tx = 0; tx < BOARD_SIZE; tx++) {
                            if (board[ty][tx].type === 'sun' && isConnected(x, y, tx, ty)) {
                                sunConnected = true;
                                break;
                            }
                        }
                        if (sunConnected) break;
                    }
                } else {
                    sunConnected = true; // Doesn't need sun, so consider it "connected"
                }
                
                // Plant is fully connected only if ALL its needs are met
                if ((!species.needs.includes('water') || waterConnected) && 
                    (!species.needs.includes('sun') || sunConnected)) {
                    connectedPlants++;
                }
            }
        }
    }
    
    const newScore = totalPlants > 0 ? Math.floor((connectedPlants / totalPlants) * 100) : 0;
    if (newScore !== score) {
        score = newScore;
        updateScore();
    }
    
    if (score === 100) {
        gameActive = false;
        levelComplete();
    } else if (turn >= maxTurns) {
        gameActive = false;
        showMessage(`üíÄ Time's up! You restored ${score}% of the ecosystem. Total Score: ${totalScore}`, true);
    }
    
    updateConnectionVisuals();
}
    function isConnected(x1, y1, x2, y2) {
        if (x1 === x2 && y1 === y2) return true;
        
        const visited = new Set();
        const queue = [{x: x1, y: y1}];
        visited.add(`${x1},${y1}`);
        
        while (queue.length > 0) {
            const {x, y} = queue.shift();
            
            const directions = [
                {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}
            ];
            
            for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                const key = `${nx},${ny}`;
                
                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && !visited.has(key)) {
                    if (nx === x2 && ny === y2) {
                        return true;
                    }
                    
                    const tileType = board[ny][nx].type;
                    if (tileType === 'path' || tileType === 'bridge' || tileType === 'water' || tileType === 'sun' ||
                        (nx === x1 && ny === y1) || (nx === x2 && ny === y2)) {
                        visited.add(key);
                        queue.push({x: nx, y: ny});
                    }
                }
            }
        }
        
        return false;
    }

    function levelComplete() {
        const bonusPoints = (maxTurns - turn) * 5 * level;
        levelScore += bonusPoints;
        totalScore += bonusPoints;
        
        playSound('level');
        
        document.getElementById('completed-level').textContent = level;
        document.getElementById('level-score').textContent = levelScore;
        document.getElementById('new-total-score').textContent = totalScore;
        document.getElementById('next-level').textContent = level + 1;
        document.getElementById('level-up-screen').style.display = 'flex';
    }

    function startNextLevel() {
        level++;
        document.getElementById('level-up-screen').style.display = 'none';
        initGame();
    }

    // ================
    // UI UPDATES
    // ================
    function renderSpeciesList() {
        const list = document.getElementById('species-list');
        list.innerHTML = '';
        
        SPECIES.forEach(species => {
            const card = document.createElement('div');
            card.className = 'species-card';
            card.innerHTML = `
                <div class="species-name">${species.emoji} ${species.name}</div>
                <div style="font-size:0.9em; color:#666;">
                    Needs: ${species.needs.map(n => n === 'water' ? 'üíß' : '‚òÄÔ∏è').join(' + ')}
                </div>
                ${discoveredSpecies.includes(species.name) ? 
                    `<div style="font-size:0.8em; margin-top:5px;">${species.desc}</div>` : 
                    '<div style="font-size:0.8em; color:#999;">Not discovered yet</div>'}
            `;
            list.appendChild(card);
        });
    }

    function updateResourceCounts() {
        document.getElementById('water-count').textContent = countResources('water');
        document.getElementById('sun-count').textContent = countResources('sun');
    }

    function countResources(type) {
        let count = 0;
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === type) count++;
            }
        }
        return count;
    }

    function updateScore() {
        document.getElementById('score').textContent = score + '%';
        document.getElementById('health-bar').style.width = `${score}%`;
        
        const healthBar = document.getElementById('health-bar');
        if (score < 30) {
            healthBar.style.background = 'linear-gradient(90deg, #d32f2f, #f44336)';
        } else if (score < 70) {
            healthBar.style.background = 'linear-gradient(90deg, #f44336, #ff9800)';
        } else {
            healthBar.style.background = 'linear-gradient(90deg, #ff9800, #4caf50)';
        }
    }

    function updateTotalScore() {
        document.getElementById('total-score-value').textContent = totalScore;
    }

    function updateLevelDisplay() {
        document.getElementById('level').textContent = level;
        document.getElementById('max-turns').textContent = maxTurns;
    }

    function updateTurnCounter() {
        document.getElementById('turn-count').textContent = turn;
        const counter = document.getElementById('turn-count').parentElement;
        if (turn > maxTurns - 5) {
            counter.style.background = 'rgba(211,47,47,0.8)';
        } else {
            counter.style.background = 'rgba(0,0,0,0.4)';
        }
    }

    function updateCooldowns() {
        bridgeCooldown = Math.max(0, 3 - (turn - lastBridgeTurn));
        clearCooldown = Math.max(0, 5 - (turn - lastClearTurn));
        
        document.getElementById('bridge-cooldown').textContent = 
            bridgeCooldown > 0 ? `${bridgeCooldown} turn${bridgeCooldown !== 1 ? 's' : ''}` : 'Ready!';
        document.getElementById('clear-cooldown').textContent = 
            clearCooldown > 0 ? `${clearCooldown} turn${clearCooldown !== 1 ? 's' : ''}` : 'Ready!';
        
        document.getElementById('bridge-btn').disabled = bridgeCooldown > 0;
        document.getElementById('clear-btn').disabled = clearCooldown > 0;
    }

    function showMessage(text, isWarning) {
        const msg = document.getElementById('message');
        msg.textContent = text;
        msg.className = isWarning ? 'message-box warning' : 'message-box';
        
        if (!isWarning) {
            clearTimeout(window.messageTimeout);
            window.messageTimeout = setTimeout(() => {
                msg.style.opacity = '0';
                setTimeout(() => {
                    if (msg.style.opacity === '0') {
                        msg.textContent = '';
                        msg.style.opacity = '1';
                    }
                }, 300);
            }, 3000);
        }
    }

    // ================
    // HELPER FUNCTIONS
    // ================
    function getEmptyTiles() {
        const tiles = [];
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                if (board[y][x].type === 'empty') tiles.push({x, y});
            }
        }
        return tiles;
    }

    function getRandomSpecies() {
        const pool = [];
        SPECIES.forEach(species => {
            for (let i = 0; i < (4 - species.rarity); i++) {
                pool.push(species);
            }
        });
        return pool[Math.floor(Math.random() * pool.length)];
    }

    function getRandomThreat() {
        return THREATS[Math.floor(Math.random() * THREATS.length)];
    }

    function findSpecies(emoji) {
        return SPECIES.find(s => s.emoji === emoji) || SPECIES[0];
    }

    function resetGame() {
        level = 1;
        totalScore = 0;
        initGame();
        showMessage("Game reset! Connect plants to resources.", false);
    }

    // Start the game
    initGame();
</script>
</body>
</html>
