<!DOCTYPE html>
<html>
<head>
  <title>Tasmanian Tangle: Debugged</title>
  <style>
    body { font-family: 'Arial', sans-serif; background: #e8f4ea; text-align: center; margin: 0; padding: 20px; color: #2c4f3b; }
    h1 { color: #1a3d2d; }
    #game-container { display: flex; justify-content: center; gap: 20px; margin: 20px auto; max-width: 900px; }
    #game-board { display: grid; grid-template-columns: repeat(8, 60px); grid-gap: 2px; background: #c8d8c9; padding: 10px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
    .tile { width: 60px; height: 60px; background: #d8e8d9; border: 1px solid #a3c1a3; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 24px; transition: all 0.2s; border-radius: 4px; }
    .tile:hover { transform: scale(1.05); }
    .tile.native { background: #88cc88; }
    .tile.weed { background: #ff8c8c; animation: pulse 1.5s infinite; }
    .tile.water { background: #a5d8e8; }
    .tile.sun { background: #fff3b0; }
    .tile.path { background: #b8e0b8; }
    .tile.selected { outline: 3px solid #ffd700; box-shadow: 0 0 10px #ffd700; }
    #sidebar { width: 200px; background: #d8e8d9; padding: 15px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); text-align: left; }
    #message { font-weight: bold; min-height: 50px; padding: 10px; background: #e8f4ea; border-radius: 4px; margin: 10px 0; }
    button { padding: 8px 15px; background: #2e8b57; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 5px; font-weight: bold; }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
    .species-card { background: white; padding: 8px; margin: 5px 0; border-radius: 4px; font-size: 14px; }
  </style>
</head>
<body>
  <h1>üåø Tasmanian Tangle (Debugged)</h1>
  <div id="game-container">
    <div id="game-board"></div>
    <div id="sidebar">
      <h3>Ecosystem Health: <span id="score">0</span>/100</h3>
      <div id="message">Connect native plants to resources!</div>
      <button onclick="resetBoard()">New Biome</button>
      <h3>Native Species:</h3>
      <div id="species-list">
        <div class="species-card">üü¢ <b>Leatherwood</b>: Needs water + sun</div>
        <div class="species-card">üå≤ <b>Huon Pine</b>: Needs water</div>
      </div>
    </div>
  </div>

  <script>
    // Game Config
    const BOARD_SIZE = 8;
    const SPECIES = [
      { emoji: 'üü¢', name: 'Leatherwood', needs: ['water', 'sun'] },
      { emoji: 'üå≤', name: 'Huon Pine', needs: ['water'] }
    ];
    
    // Game State
    let board = [];
    let selectedTile = null;
    let score = 0;
    let turn = 0;

    // Initialize
    function initBoard() {
      const gameBoard = document.getElementById('game-board');
      gameBoard.innerHTML = '';
      board = [];
      selectedTile = null;
      score = 0;
      turn = 0;
      updateScore();
      showMessage('Connect native plants to resources!');
      
      // Create tiles
      for (let y = 0; y < BOARD_SIZE; y++) {
        board[y] = [];
        for (let x = 0; x < BOARD_SIZE; x++) {
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.dataset.x = x;
          tile.dataset.y = y;
          tile.addEventListener('click', () => handleTileClick(x, y));
          gameBoard.appendChild(tile);
          board[y][x] = { type: 'empty', element: tile };
        }
      }

      // Place elements (guaranteed non-overlapping)
      placeRandom('water', 'üíß', 3);
      placeRandom('sun', '‚òÄÔ∏è', 3);
      placeRandom('native', SPECIES[0].emoji, 3);
      placeRandom('native', SPECIES[1].emoji, 2);
      placeRandom('weed', 'üî¥', 3);
    }

    // Place random items without overlap
    function placeRandom(type, emoji, count) {
      let placed = 0;
      while (placed < count) {
        const x = Math.floor(Math.random() * BOARD_SIZE);
        const y = Math.floor(Math.random() * BOARD_SIZE);
        if (board[y][x].type === 'empty') {
          board[y][x].type = type;
          board[y][x].element.textContent = emoji;
          board[y][x].element.classList.add(type);
          placed++;
        }
      }
    }

    // Handle clicks
    function handleTileClick(x, y) {
      const tile = board[y][x];
      
      // Select native plant
      if (tile.type === 'native') {
        if (selectedTile) selectedTile.element.classList.remove('selected');
        selectedTile = { x, y, species: findSpecies(tile.element.textContent) };
        tile.element.classList.add('selected');
        showMessage(`Selected: ${selectedTile.species.name}`);
      } 
      // Connect to resource
      else if (selectedTile && (tile.type === 'water' || tile.type === 'sun')) {
        if (selectedTile.species.needs.includes(tile.type)) {
          if (connectTiles(selectedTile.x, selectedTile.y, x, y)) {
            selectedTile.element.classList.remove('selected');
            selectedTile = null;
            endTurn();
          }
        } else {
          showMessage(`This plant doesn't need ${tile.type}!`, true);
        }
      }
    }

    // Bresenham's line algorithm (optimized)
    function connectTiles(x1, y1, x2, y2) {
      const path = [];
      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const sx = (x1 < x2) ? 1 : -1;
      const sy = (y1 < y2) ? 1 : -1;
      let err = dx - dy;

      // Check path validity first
      let x = x1;
      let y = y1;
      while (true) {
        if (!(x === x1 && y === y1) && !(x === x2 && y === y2)) {
          if (board[y][x].type === 'weed') {
            showMessage("üö´ Path blocked by weeds!", true);
            return false;
          }
          if (board[y][x].type !== 'empty' && board[y][x].type !== 'path') {
            showMessage("üö´ Path blocked!", true);
            return false;
          }
          path.push({x, y});
        }
        
        if (x === x2 && y === y2) break;
        
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x += sx; }
        if (e2 < dx) { err += dx; y += sy; }
      }

      // Draw the path if valid
      path.forEach(({x, y}) => {
        board[y][x].type = 'path';
        board[y][x].element.textContent = 'üå±';
        board[y][x].element.classList.add('path');
      });

      return true;
    }

    // End turn (weeds spread, check win)
    function endTurn() {
      turn++;
      spreadWeeds();
      checkWin();
    }

    // Weeds spread more predictably
    function spreadWeeds() {
      const weedTiles = [];
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'weed') weedTiles.push({x, y});
        }
      }

      let newWeeds = 0;
      weedTiles.forEach(({x, y}) => {
        const directions = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        for (const dir of directions) {
          const nx = x + dir.dx;
          const ny = y + dir.dy;
          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && 
              board[ny][nx].type === 'empty' && Math.random() < 0.5 && newWeeds < weedTiles.length) {
            board[ny][nx].type = 'weed';
            board[ny][nx].element.textContent = 'üî¥';
            board[ny][nx].element.classList.add('weed');
            newWeeds++;
            break; // Limit 1 spread per weed per turn
          }
        }
      });

      if (newWeeds > 0) showMessage(`Weeds spread to ${newWeeds} tiles!`, true);
    }

    // Check win/lose conditions
    function checkWin() {
      let connectedPlants = 0;
      let totalPlants = 0;
      let hasValidMoves = false;

      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x].type === 'native') {
            totalPlants++;
            const species = findSpecies(board[y][x].element.textContent);
            let needsMet = 0;

            // Check connections to required resources
            for (let ty = 0; ty < BOARD_SIZE; ty++) {
              for (let tx = 0; tx < BOARD_SIZE; tx++) {
                if ((board[ty][tx].type === 'water' && species.needs.includes('water')) {
                  if (isConnected(x, y, tx, ty)) needsMet++;
                }
                if ((board[ty][tx].type === 'sun' && species.needs.includes('sun')) {
                  if (isConnected(x, y, tx, ty)) needsMet++;
                }
              }
            }

            // Check if plant has unmet needs AND possible moves
            if (needsMet < species.needs.length) {
              for (let ty = 0; ty < BOARD_SIZE; ty++) {
                for (let tx = 0; tx < BOARD_SIZE; tx++) {
                  if ((board[ty][tx].type === 'water' || board[ty][tx].type === 'sun') && 
                      species.needs.includes(board[ty][tx].type)) {
                    if (hasClearPath(x, y, tx, ty)) hasValidMoves = true;
                  }
                }
              }
            }

            if (needsMet >= species.needs.length) connectedPlants++;
          }
        }
      }

      score = Math.floor((connectedPlants / totalPlants) * 100);
      updateScore();

      if (score === 100) {
        showMessage("üéâ Biome restored! Well done!", false);
      } else if (!hasValidMoves) {
        showMessage("üíÄ No possible moves‚Äîweeds won!", true);
      }
    }

    // Fast path check (no visual updates)
    function hasClearPath(x1, y1, x2, y2) {
      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const sx = (x1 < x2) ? 1 : -1;
      const sy = (y1 < y2) ? 1 : -1;
      let err = dx - dy;

      let x = x1;
      let y = y1;
      while (true) {
        if (!(x === x1 && y === y1) && !(x === x2 && y === y2)) {
          if (board[y][x].type === 'weed' || 
             (board[y][x].type !== 'empty' && board[y][x].type !== 'path')) {
            return false;
          }
        }
        
        if (x === x2 && y === y2) return true;
        
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x += sx; }
        if (e2 < dx) { err += dx; y += sy; }
      }
    }

    // Flood-fill connection check (optimized)
    function isConnected(x1, y1, x2, y2) {
      if (x1 === x2 && y1 === y2) return true;
      
      const visited = new Set();
      const queue = [{x: x1, y: y1}];
      visited.add(`${x1},${y1}`);

      while (queue.length > 0) {
        const {x, y} = queue.shift();
        const directions = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];

        for (const dir of directions) {
          const nx = x + dir.dx;
          const ny = y + dir.dy;
          const key = `${nx},${ny}`;

          if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && !visited.has(key)) {
            if (nx === x2 && ny === y2) return true;
            
            if (board[ny][nx].type === 'path' || board[ny][nx].type === 'water' || board[ny][nx].type === 'sun') {
              visited.add(key);
              queue.push({x: nx, y: ny});
            }
          }
        }
      }
      return false;
    }

    // Helper functions
    function findSpecies(emoji) {
      return SPECIES.find(s => s.emoji === emoji) || SPECIES[0];
    }
    
    function updateScore() {
      document.getElementById('score').textContent = score;
    }
    
    function showMessage(text, isWarning = false) {
      const msg = document.getElementById('message');
      msg.textContent = text;
      msg.style.color = isWarning ? '#d32f2f' : '#2e8b57';
    }

    function resetBoard() {
      initBoard();
    }

    // Start the game
    initBoard();
  </script>
</body>
</html>
